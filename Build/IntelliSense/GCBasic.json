{
    "classes": [
        {
            "title": "Variable Types",
            "description": "Common and advanced variable types, acceced by AS",
            "funcs": {
                "Bit": {
                    "signature": "Dim MyVar as Bit",
                    "description": "A bit (0 or 1)"
                },
                "Byte": {
                    "signature": "Dim MyVar as Byte",
                    "description": "A whole number between 0 and 255"
                },
                "Word": {
                    "signature": "Dim MyVar as Word",
                    "description": "A whole number between 0 and 65535"
                },
                "Integer": {
                    "signature": "Dim MyVar as Integer",
                    "description": "A whole number between -32768 and 32767"
                },
                "Long": {
                    "signature": "Dim MyVar as Long",
                    "description": "A whole number between 0 and 2^32 (4.29 billion)"
                },
                "String": {
                    "signature": "Dim MyVar as String",
                    "description": "A series of letters, numbers and symbols"
                },
                "LongINT": {
                    "signature": "Dim MyVar as LongINT",
                    "description": "A list of whole numbers between - (2 ^ 63) and 2 ^ 63 - 1"
                },
                "uLongINT": {
                    "signature": "Dim MyVar as uLongINT",
                    "description": "A whole number between 0 and 2 ^ 64 - 1"
                },
                "Single": {
                    "signature": "Dim MyVar as Single",
                    "description": "A numeric floating point values that range from -3.4x10 ^ 38 and +3.4x10 ^ 38 with up to seven significant digits"
                },
                "Double": {
                    "signature": "Dim MyVar as Double",
                    "description": "A numeric floating point values that range from -1.7x10 ^ 308 and +1.7x10 ^ 308 with up to 15 significant digits"
                }
            },
            "extends": "",
            "accessor": "as"
        },
        {
            "title": "Exit Types",
            "description": "This class contains all Exit Types",
            "funcs": {
                "Sub": {
                    "signature": "Exit Sub",
                    "description": "The program exit the current subroutine, Applies to Subroutines"
                },
                "Function": {
                    "signature": "Exit Function",
                    "description": "The program exit the current function, Applies to Functions"
                },
                "Do": {
                    "signature": "Exit Do",
                    "description": "The program exit the current Do-Loop, Applies to Do-Loops"
                },
                "For": {
                    "signature": "Exit For",
                    "description": "The program exit the current For-Next, Applies to For-Next Loops"
                },
                "Repeat": {
                    "signature": "Exit Repeat",
                    "description": "The program exit the current Repeat-Loop, Applies to Repeat-Loop"
                }
            },
            "extends": "",
            "accessor": "exit"
        },
        {
            "title": "End Types",
            "description": "This class contains all End Types",
            "funcs": {
                "If": {
                    "signature": "End If",
                    "description": "Finish the current If, Applies to If"
                },
                "Select": {
                    "signature": "End Select",
                    "description": "Finish the current Select Case, Applies to Select Case"
                },
                "Repeat": {
                    "signature": "End Repeat",
                    "description": "Finish the current Repeat, Applies to Repeat"
                },
                "Table": {
                    "signature": "End Table",
                    "description": "Finish the current Table, Applies to Tables"
                },
                "Sub": {
                    "signature": "End Sub",
                    "description": "Finish the current Sub, Applies to Subroutines"
                },
                "Macro": {
                    "signature": "End Macro",
                    "description": "Finish the current Macro, Applies to Macros"
                },
                "EEPROM": {
                    "signature": "End EEPROM",
                    "description": "Finish the current dataset, Applies to EEPROM"
                },
                "DATA": {
                    "signature": "End DATA",
                    "description": "Finish the current data block, Applies to DATA"
                },
                "ENUM": {
                    "signature": "End Enum",
                    "description": "Finish the current ENUM block, Applies to Enum"
                },                        
                "Function": {
                    "signature": "End Function",
                    "description": "Finish the current Function, Applies to Functions"
                }
            },
            "extends": "",
            "accessor": "end"
        },
        {
            "title": "FVRInitialize Types",
            "description": "This class contains all FVRInitialize Types",
            "funcs": {
                "(FVR_OFF)": {
                    "signature": "FVRInitialize (FVR_OFF)",
                    "description": "Fixed Voltage Reference is set to OFF"
                },
                "(FVR_1X)": {
                    "signature": "FVRInitialize (FVR_1X)",
                    "description": "Fixed Voltage Reference is set to 1.024v"
                },
                "(FVR_2X)": {
                    "signature": "FVRInitialize (FVR_2X)",
                    "description": "Fixed Voltage Reference is set to 2.048v"
                },
                "(FVR_4X)": {
                    "signature": "FVRInitialize (FVR_4X)",
                    "description": "Fixed Voltage Reference is set to 4.096v"
                }
            },
            "extends": "",
            "accessor": "fvrinitialize"
        },
        {
            "title": "Do Types",
            "description": "This class contains all Do Types",
            "funcs": {
                "While": {
                    "signature": "Do While"
                },
                "Until": {
                    "signature": "Do Until"
                },
                "Forever": {
                    "signature": "Do Forever"
                }
            },
            "extends": "",
            "accessor": "do"
        },
        {
            "title": "LCD BackLight",
            "description": "This class contains all LCD BackLight modes",
            "funcs": {
                "(On)": {
                    "signature": "LCDBacklight (On)"
                },
                "(Off)": {
                    "signature": "LCDBacklight (Off)"
                }
            },
            "extends": "",
            "accessor": "lcdbacklight"
        },
        {
            "title": "GLCD Display",
            "description": "This class contains all GLCD Display modes",
            "funcs": {
                "(On)": {
                    "signature": "GLCDDisplay (On)"
                },
                "(Off)": {
                    "signature": "GLCDDisplay (Off)"
                }
            },
            "extends": "",
            "accessor": "glcddisplay"
        },
        {
            "title": "HI2CMode Modes",
            "description": "This class contains all HI2CMode modes",
            "funcs": {
                "(Master)": {
                    "signature": "HI2CMode (Master)"
                },
                "(Slave)": {
                    "signature": "HI2CMode (Slave)"
                }
            },
            "extends": "",
            "accessor": "hi2cmode"
        },
        {
            "title": "Interrupt Events",
            "description": "This class contains all Interrupt Events",
            "funcs": {
                "ADCReady": {
                    "signature": "Microchip&AVR",
                    "description": "The analog/digital converter has finished a conversion"
                },
                "BatteryFail": {
                    "signature": "AVR",
                    "description": "The battery has failed in some way. This is only implemented on the ATmega406"
                },
                "CANActivity": {
                    "signature": "Microchip",
                    "description": "CAN bus activity is taking place"
                },
                "CANBadMessage": {
                    "signature": "Microchip",
                    "description": "A bad CAN message has been received"
                },
                "CANError": {
                    "signature": "Microchip&AVR",
                    "description": "Some CAN error has occured"
                },
                "CANHighWatermark": {
                    "signature": "Microchip",
                    "description": "CAN high watermark reached"
                },
                "CANRx0Ready": {
                    "signature": "Microchip",
                    "description": "New message present in buffer 0"
                },
                "CANRx1Ready": {
                    "signature": "Microchip",
                    "description": "New message present in buffer 1"
                },
                "CANRx2Ready": {
                    "signature": "Microchip",
                    "description": "New message present in buffer 2"
                },
                "CANRxReady": {
                    "signature": "Microchip",
                    "description": "New message present"
                },
                "CANTransferComplete": {
                    "signature": "AVR",
                    "description": "Transfer of data has been completed"
                },
                "CANTx0Ready": {
                    "signature": "Microchip",
                    "description": "Buffer 0 has been sent"
                },
                "CANTx1Ready": {
                    "signature": "Microchip",
                    "description": "Buffer 1 has been sent"
                },
                "CANTx2Ready": {
                    "signature": "Microchip",
                    "description": "Buffer 2 has been sent"
                },
                "CANTxReady": {
                    "signature": "Microchip",
                    "description": "Sending has completed"
                },
                "CCADCAccReady": {
                    "signature": "AVR",
                    "description": "CC ADC accumulate conversion finished (ATmega406 only)"
                },
                "CCADCReady": {
                    "signature": "AVR",
                    "description": "CC ADC instantaneous conversion finished (ATmega406 only)"
                },
                "CCADCRegular": {
                    "signature": "AVR",
                    "description": "CC ADC regular conversion finished (ATmega406 only)"
                },
                "CCP1": {
                    "signature": "Microchip",
                    "description": "The CCP1 module has captured an event"
                },
                "CCP2": {
                    "signature": "Microchip",
                    "description": "The CCP2 module has captured an event"
                },
                "CCP3": {
                    "signature": "Microchip",
                    "description": "The CCP3 module has captured an event"
                },
                "CCP4": {
                    "signature": "Microchip",
                    "description": "The CCP4 module has captured an event"
                },
                "CCP5": {
                    "signature": "Microchip",
                    "description": "The CCP5 module has captured an event"
                },
                "Comp0Change": {
                    "signature": "Microchip&AVR",
                    "description": "The output of comparator 0 has changed"
                },
                "Comp1Change": {
                    "signature": "Microchip&AVR",
                    "description": "The output of comparator 1 has changed"
                },
                "Comp2Change": {
                    "signature": "Microchip&AVR",
                    "description": "The output of comparator 2 has changed"
                },
                "Crypto": {
                    "signature": "Microchip",
                    "description": "The KEELOQ module has generated an interrupt"
                },
                "EEPROMReady": {
                    "signature": "Microchip&AVR",
                    "description": "An EEPROM write has finished"
                },
                "Ethernet": {
                    "signature": "Microchip",
                    "description": "The Ethernet module has generated an interrupt. This must be dealt within the handler."
                },
                "ExtInt0": {
                    "signature": "Microchip&AVR",
                    "description": "External Interrupt pin 0 has been detected"
                },
                "ExtInt1": {
                    "signature": "Microchip&AVR",
                    "description": "External Interrupt pin 1 has been detected"
                },
                "ExtInt2": {
                    "signature": "Microchip&AVR",
                    "description": "External Interrupt pin 2 has been detected"
                },
                "ExtInt3": {
                    "signature": "Microchip&AVR",
                    "description": "External Interrupt pin 3 has been detected"
                },
                "ExtInt4": {
                    "signature": "AVR",
                    "description": "External Interrupt pin 4 has been detected"
                },
                "ExtInt5": {
                    "signature": "AVR",
                    "description": "External Interrupt pin 5 has been detected"
                },
                "ExtInt6": {
                    "signature": "AVR",
                    "description": "External Interrupt pin 6 has been detected"
                },
                "ExtInt7": {
                    "signature": "AVR",
                    "description": "External Interrupt pin 7 has been detected"
                },
                "GPIOChange": {
                    "signature": "Microchip",
                    "description": "The pins on port GPIO have changed"
                },
                "LCDReady": {
                    "signature": "Microchip&AVR",
                    "description": "The LCD is about to draw a segment"
                },
                "LPWU": {
                    "signature": "Microchip",
                    "description": "The Low Power Wake Up has been detected"
                },
                "OscillatorFail": {
                    "signature": "Microchip",
                    "description": "The external oscillator has failed, and the microcontroller is running from an internal oscillator."
                },
                "PinChange": {
                    "signature": "AVR",
                    "description": "Logic level of PCINT pin has changed"
                },
                "PinChange0": {
                    "signature": "AVR",
                    "description": "Logic level of PCINT0 pin has changed"
                },
                "PinChange1": {
                    "signature": "AVR",
                    "description": "Logic level of PCINT1 pin has changed"
                },
                "PinChange2": {
                    "signature": "AVR",
                    "description": "Logic level of PCINT2 pin has changed"
                },
                "PinChange3": {
                    "signature": "AVR",
                    "description": "Logic level of PCINT3 pin has changed"
                },
                "PinChange4": {
                    "signature": "AVR",
                    "description": "Logic level of PCINT4 pin has changed"
                },
                "PinChange5": {
                    "signature": "AVR",
                    "description": "Logic level of PCINT5 pin has changed"
                },
                "PinChange6": {
                    "signature": "AVR",
                    "description": "Logic level of PCINT6 pin has changed"
                },
                "PinChange7": {
                    "signature": "AVR",
                    "description": "Logic level of PCINT7 pin has changed"
                },
                "PMPReady": {
                    "signature": "Microchip",
                    "description": "A Parallel Master Port read or write has finished"
                },
                "PORTChange": {
                    "signature": "Microchip",
                    "description": "The pins on ports ABCEDEF have changed. This is generic port change interrupt. You must inspect the source to ensure you are handlign the correct interrupt."
                },
                "PORTAChange": {
                    "signature": "Microchip",
                    "description": "The pins on port A have changed"
                },
                "PORTABChange": {
                    "signature": "Microchip",
                    "description": "The pins on port A and/or B have changed"
                },
                "PORTBChange": {
                    "signature": "Microchip&AVR",
                    "description": "The pins on port B have changed"
                },
                "PSC0Capture": {
                    "signature": "AVR",
                    "description": "The counter for Power Stage Controller 0 matches the value in a compare register, the value of the counter has been captured, or a synchronisation error has occurred"
                },
                "PSC0EndCycle": {
                    "signature": "AVR",
                    "description": "Power Stage Controller 0 has reached the end of its cycle"
                },
                "PSC1Capture": {
                    "signature": "AVR",
                    "description": "The counter for Power Stage Controller 1 matches the value in a compare register, the value of the counter has been captured, or a synchronisation error has occurred"
                },
                "PSC1EndCycle": {
                    "signature": "AVR",
                    "description": "Power Stage Controller 1 has reached the end of its cycle"
                },
                "PSC2Capture": {
                    "signature": "AVR",
                    "description": "The counter for Power Stage Controller 2 matches the value in a compare register, the value of the counter has been captured, or a synchronisation error has occurred"
                },
                "PSC2EndCycle": {
                    "signature": "AVR",
                    "description": "Power Stage Controller 2 has reached the end of its cycle"
                },
                "PSPReady": {
                    "signature": "Microchip",
                    "description": "A Parallel Slave Port read or write has finished"
                },
                "PWMTimeBase": {
                    "signature": "Microchip",
                    "description": "The PWM time base matches the PWM Time Base Period register (PTPER)"
                },
                "SPIReady": {
                    "signature": "AVR",
                    "description": "The SPI module has finished the previous transfer"
                },
                "SPMReady": {
                    "signature": "AVR",
                    "description": "A write to program memory by the spm instruction has finished"
                },
                "SPPReady": {
                    "signature": "Microchip",
                    "description": "A SPP read or write has finished"
                },
                "SSP1Collision": {
                    "signature": "Microchip",
                    "description": "SSP1 has detected a bus collision"
                },
                "SSP1Ready": {
                    "signature": "Microchip",
                    "description": "The SSP/SSP1/MSSP1 module has finished sending or receiving"
                },
                "SSP2Collision": {
                    "signature": "Microchip",
                    "description": "SSP2 has detected a bus collision"
                },
                "SSP2Ready": {
                    "signature": "Microchip",
                    "description": "The SSP2/MSSP2 module has finished sending or receiving"
                },
                "Timer0Capture": {
                    "signature": "AVR",
                    "description": "An input event on the pin ICP0 has caused the value of Timer 0 to be captured in the ICR0 register"
                },
                "Timer0Match1": {
                    "signature": "AVR",
                    "description": "Timer 0 matches the Timer 0 output compare register A (OCR0A)"
                },
                "Timer0Match2": {
                    "signature": "AVR",
                    "description": "Timer 0 matches the Timer 0 output compare register B (OCR0B)"
                },
                "Timer0Overflow": {
                    "signature": "Microchip&AVR",
                    "description": "Timer 0 has overflowed"
                },
                "Timer1Capture": {
                    "signature": "AVR",
                    "description": "An input event on the pin ICP1 has caused the value of Timer 1 to be captured in the ICR1 register"
                },
                "Timer1Error": {
                    "signature": "AVR",
                    "description": "The Timer 1 Fault Protection unit has been detected by an input on the INT0 pin"
                },
                "Timer1Match1": {
                    "signature": "AVR",
                    "description": "Timer 1 matches the Timer 1 output compare register A (OCR1A) "
                },
                "Timer1Match2": {
                    "signature": "AVR",
                    "description": "Timer 1 matches the Timer 1 output compare register B (OCR1B)"
                },
                "Timer1Match3": {
                    "signature": "AVR",
                    "description": "Timer 1 matches the Timer 1 output compare register C (OCR1C)"
                },
                "Timer1Match4": {
                    "signature": "AVR",
                    "description": "Timer 1 matches the Timer 1 output compare register D (OCR1D)"
                },
                "Timer1Overflow": {
                    "signature": "Microchip&AVR",
                    "description": "Timer 1 has overflowed"
                },
                "Timer2Match": {
                    "signature": "Microchip",
                    "description": "Timer 2 matches the Timer 2 output compare register (PR2)"
                },
                "Timer2Match1": {
                    "signature": "AVR",
                    "description": "Timer 2 matches the Timer 2 output compare register A (OCR2A)"
                },
                "Timer2Match2": {
                    "signature": "AVR",
                    "description": "Timer 2 matches the Timer 2 output compare register B (OCR2B)"
                },
                "Timer2Overflow": {
                    "signature": "AVR",
                    "description": "Timer 2 has overflowed"
                },
                "Timer3Capture": {
                    "signature": "AVR",
                    "description": "An input event on the pin ICP3 has caused the value of Timer 3 to be captured in the ICR3 register"
                },
                "Timer3Match1": {
                    "signature": "AVR",
                    "description": "Timer 3 matches the Timer 3 output compare register A (OCR3A)"
                },
                "Timer3Match2": {
                    "signature": "AVR",
                    "description": "Timer 3 matches the Timer 3 output compare register B (OCR3B)"
                },
                "Timer3Match3": {
                    "signature": "AVR",
                    "description": "Timer 3 matches the Timer 3 output compare register C (OCR3C)"
                },
                "Timer3Overflow": {
                    "signature": "Microchip&AVR",
                    "description": "Timer 3 has overflowed"
                },
                "Timer4Capture": {
                    "signature": "AVR",
                    "description": "An input event on the pin ICP4 has caused the value of Timer 4 to be captured in the ICR4 register"
                },
                "Timer4Match": {
                    "signature": "Microchip",
                    "description": "Timer 4 matches the Timer 4 output compare register (PR4)"
                },
                "Timer4Match1": {
                    "signature": "AVR",
                    "description": "Timer 4 matches the Timer 4 output compare register A (OCR4A)"
                },
                "Timer4Match2": {
                    "signature": "AVR",
                    "description": "Timer 4 matches the Timer 4 output compare register B (OCR4B)"
                },
                "Timer4Match3": {
                    "signature": "AVR",
                    "description": "Timer 4 matches the Timer 4 output compare register C (OCR4C)"
                },
                "Timer4Overflow": {
                    "signature": "AVR",
                    "description": "Timer 4 has overflowed"
                },
                "Timer5CAP1": {
                    "signature": "Microchip",
                    "description": "An input on the CAP1 pin has caused the value of Timer 5 to be captured in CAP1BUF"
                },
                "Timer5CAP2": {
                    "signature": "Microchip",
                    "description": "An input on the CAP2 pin has caused the value of Timer 5 to be captured in CAP2BUF"
                },
                "Timer5CAP3": {
                    "signature": "Microchip",
                    "description": "An input on the CAP3 pin has caused the value of Timer 5 to be captured in CAP3BUF"
                },
                "Timer5Capture": {
                    "signature": "AVR",
                    "description": "An input event on the pin ICP5 has caused the value of Timer 5 to be captured in the ICR5 register"
                },
                "Timer5Match1": {
                    "signature": "AVR",
                    "description": "Timer 5 matches the Timer 5 output compare register A (OCR5A)"
                },
                "Timer5Match2": {
                    "signature": "AVR",
                    "description": "Timer 5 matches the Timer 5 output compare register B (OCR5B)"
                },
                "Timer5Match3": {
                    "signature": "AVR",
                    "description": "Timer 5 matches the Timer 5 output compare register C (OCR5C)"
                },
                "Timer5Overflow": {
                    "signature": "Microchip&AVR",
                    "description": "Timer 5 has overflowed"
                },
                "Timer6Match": {
                    "signature": "Microchip",
                    "description": "Timer 6 matches the Timer 6 output compare register (PR6)"
                },
                "Timer7Overflow": {
                    "signature": "Microchip",
                    "description": "Timer 7 has overflowed"
                },
                "Timer8Match": {
                    "signature": "Microchip",
                    "description": "Timer 8 matches the Timer 8 output compare register (PR8)"
                },
                "Timer10Match": {
                    "signature": "Microchip",
                    "description": "Timer 10 matches the Timer 10 output compare register (PR10)"
                },
                "Timer12Match": {
                    "signature": "Microchip",
                    "description": "Timer 12 matches the Timer 12 output compare register (PR12)"
                },
                "TWIConnect": {
                    "signature": "Microchip&AVR",
                    "description": "The Atmel AVR has been connected to or disconnected from the TWI (I2C) bus"
                },
                "TWIReady": {
                    "signature": "Microchip&AVR",
                    "description": "The TWI has finished the previous transmission and is ready to send or receive more data"
                },
                "UsartRX1Ready": {
                    "signature": "Microchip&AVR",
                    "description": "UART/USART 1 has received data"
                },
                "UsartRX2Ready": {
                    "signature": "Microchip&AVR",
                    "description": "UART/USART 2 has received data"
                },
                "UsartRX3Ready": {
                    "signature": "AVR",
                    "description": "UART/USART 3 has received data"
                },
                "UsartRX4Ready": {
                    "signature": "AVR",
                    "description": "UART/USART 4 has received data"
                },
                "UsartTX1Ready": {
                    "signature": "Microchip&AVR",
                    "description": "UART/USART 1 is ready to send data"
                },
                "UsartTX1Sent": {
                    "signature": "AVR",
                    "description": "UART/USART 1 has finished sending data"
                },
                "UsartTX2Ready": {
                    "signature": "Microchip&AVR",
                    "description": "UART/USART 2 is ready to send data"
                },
                "UsartTX2Sent": {
                    "signature": "AVR",
                    "description": "UART/USART 2 has finished sending data"
                },
                "UsartTX3Ready": {
                    "signature": "AVR",
                    "description": "UART/USART 3 is ready to send data"
                },
                "UsartTX3Sent": {
                    "signature": "AVR",
                    "description": "UART/USART 3 has finished sending data"
                },
                "UsartTX4Ready": {
                    "signature": "AVR",
                    "description": "UART/USART 4 is ready to send data"
                },
                "UsartTX4Sent": {
                    "signature": "AVR",
                    "description": "UART/USART 4 has finished sending data"
                },
                "USBEndpoint": {
                    "signature": "AVR",
                    "description": "A USB endpoint has generated an interrupt"
                },
                "USB": {
                    "signature": "Microchip&AVR",
                    "description": "The USB module has generated an interrupt. This must be dealt with in the handler."
                },
                "USIOverflow": {
                    "signature": "AVR",
                    "description": "The USI counter has overflowed from 15 to 0"
                },
                "USIStart": {
                    "signature": "AVR",
                    "description": "The USI module has detected a start condition"
                },
                "VoltageFail": {
                    "signature": "Microchip",
                    "description": "The input voltage has dropped too low"
                },
                "VoltageRegulator": {
                    "signature": "AVR",
                    "description": "An interrupt has been generated by the voltage regulator (ATmega16HVA only)"
                },
                "WakeUp": {
                    "signature": "AVR",
                    "description": "The Wake-Up timer has overflowed"
                },
                "WDT": {
                    "signature": "AVR",
                    "description": "An interrupt has been generated by the Watchdog Timer"
                }
            },
            "extends": "",
            "accessor": "on interrupt"
        },
        {
            "title": "Default Includes",
            "description": "This class contains the default includes",
            "funcs": {
                "<3pi.h>": {
                    "signature": "#include <3pi.h>",
                    "description": "Subroutines to allow the Polulu 3pi robot to work with Great Cow BASIC."
                },
                "<47xxx?eeram.h>": {
                    "signature": "#include <47xxx?eeram.h>",
                    "description": "Library for Microchip EERAM - (74XXX)"
                },
                "<ADAFruit_mini_colorTFT_joystick_featherwing.h>": {
                    "signature": "#include <ADAFruit_mini_colorTFT_joystick_featherwing.h>",
                    "description": "ADAFruit_mini_colorTFT_joystick  routines for the GCBASIC compiler"
                },
                "<ads7843.h>": {
                    "signature": "#include <ads7843.h>",
                    "description": "ADS7843 routines for the GCBASIC compiler"
                },
                "<alps-ec11.h>": {
                    "signature": "#include <alps-ec11.h>",
                    "description": "encoder routines for ALPS mechanical rotary encoder EC11B/ EC11E/ EC11G/ EC11J"
                },
                "<ams_5600.h>": {
                    "signature": "#include <ams_5600.h>",
                    "description": "AMS 5600 class for Great Cow BASIC"
                },
                "<bme280.h>": {
                    "signature": "#include <bme280.h>",
                    "description": "Bosch BME280/BMP280  routines for Great Cow BASIC. This is a library for the BME280 humidity, temperature & pressure sensor."
                },
                "<canbus.h>": {
                    "signature": "#include <canbus.h>",
                    "description": "CanBus MCP2515 routines for the GCBASIC compiler"
                },
                "<chipino.h>": {
                    "signature": "#include <chipino.h>",
                    "description": "CHIPINO I/O Header File"
                },
                "<dht.h>": {
                    "signature": "#include <dht.h>",
                    "description": "This include file will let you easily exploit the DHT11 or DHT22 relative humidity/temperature sensors"
                },
                "<ds18b20.h>": {
                    "signature": "#include <ds18b20.h>",
                    "description": "DS18b20 temperature sensor routines for the GCBASIC compiler"
                },
                "<ds18b20mulltiport.h>": {
                    "signature": "#include <ds18b20mulltiport.h>",
                    "description": "Supports a multiport DS18B20 reads."
                },
                "<ds18s20.h>": {
                    "signature": "#include <ds18s20.h>",
                    "description": "DS18s20 routines for the Great Cow BASIC compiler"
                },
                "<ds1307.h>": {
                    "signature": "#include <ds1307.h>",
                    "description": "Software DS1307 routines for the GCBASIC compiler"
                },
                "<ds1337.h>": {
                    "signature": "#include <ds1337.h>",
                    "description": "Library for reading/writing to Microchip DS1337 RTC for the GCBASIC compiler"
                },
                "<ds1672.h>": {
                    "signature": "#include <ds1672.h>",
                    "description": "Library for reading/writing to Microchip DS1672 RTC for the GCBASIC compiler"
                },
                "<ds2482.h>": {
                    "signature": "#include <ds2482.h>",
                    "description": "DS2482 routines for the GCBASIC compiler"
                },
                "<ds3231.h>": {
                    "signature": "#include <ds3231.h>",
                    "description": "Library for reading/writing to Microchip DS3231 RTC for the GCBASIC compiler"
                },
                "<duemilanove.h>": {
                    "signature": "#include <duemilanove.h>",
                    "description": "Library to allow the Arduino Duemilanove (mega328) to work with GCBASIC"
                },
                "<emc1001.h>": {
                    "signature": "#include <emc1001.h>",
                    "description": " EMC1001 routines for the GCBASIC compiler"
                },
                "<EPD_EPD2in13D.h>": {
                    "signature": "#include <EPD_EPD2in13D.h>",
                    "description": "Graphical LCD routines for the GCBASIC compiler"
                },
                "<EPD_EPD7in5.h>": {
                    "signature": "#include <EPD_EPD7in5.h>",
                    "description": "Graphical LCD routines for the GCBASIC compiler"
                },
                "<eracer.h>": {
                    "signature": "#include <eracer.h>",
                    "description": "Subroutines to allow the eLabtronics eRacer robot to work with Great Cow BASIC"
                },
                "<fram.h>": {
                    "signature": "#include <fram.h>",
                    "description": "A library for a Ramtron I2C FRAM serial memory"
                },
                "<getuserid.h>": {
                    "signature": "#include <getuserid.h>",
                    "description": "MicroChip PIC specific to read GetUserID routines for Great Cow BASIC"
                },
                "<glcd.h>": {
                    "signature": "#include <glcd.h>",
                    "description": "Graphical LCD routines for the GCBASIC compiler"
                },
                "<glcd_hx8347.h>": {
                    "signature": "#include <glcd_hx8347.h>",
                    "description": " Graphical LCD routines for the GCBASIC compiler"
                },
                "<glcd_ili9326.h>": {
                    "signature": "#include <glcd_ili9326.h>",
                    "description": " Graphical LCD routines for the GCBASIC compiler"
                },
                "<glcd_ili9340.h>": {
                    "signature": "#include <glcd_ili9340.h>",
                    "description": " Graphical LCD routines for the GCBASIC compiler"
                },
                "<glcd_ili9341.h>": {
                    "signature": "#include <glcd_ili9341.h>",
                    "description": "Graphical LCD routines for the GCBASIC compiler"
                },
                "<glcd_ili9481.h>": {
                    "signature": "#include <glcd_ili9481.h>",
                    "description": " Graphical LCD routines for the GCBASIC compiler"
                },
                "<glcd_ili9486l.h>": {
                    "signature": "#include <glcd_ili9486l.h>",
                    "description": " Graphical LCD routines for the GCBASIC compiler"
                },
                "<glcd_imagesandfonts_addin3.h>": {
                    "signature": "#include <glcd_imagesandfonts_addin3.h>",
                    "description": "Graphical LCD Image and addtional Fonts routines for the GCBASIC compiler"
                },
                "<glcd_ks0108.h>": {
                    "signature": "#include <glcd_ks0108.h>",
                    "description": "Graphical LCD routines for the GCBASIC compiler"
                },
                "<glcd_nextion.h>": {
                    "signature": "#include <glcd_nextion.h>",
                    "description": " Graphical LCD routines for the GCBASIC compiler"
                },
                "<glcd_nt7108c.h>": {
                    "signature": "#include <glcd_nt7108c.h>",
                    "description": "Graphical LCD routines for the GCBASIC compiler"
                },
                "<glcd_pcd8544.h>": {
                    "signature": "#include <glcd_pcd8544.h>",
                    "description": "Graphical LCD routines for the GCBASIC compiler"
                },
                "<glcd_sh1106.h>": {
                    "signature": "#include <glcd_sh1106.h>",
                    "description": "Graphical LCD routines for the GCBASIC compiler"
                },
                "<glcd_ssd1289.h>": {
                    "signature": "#include <glcd_ssd1289.h>",
                    "description": "Graphical LCD routines for the GCBASIC compiler"
                },
                "<glcd_ssd1306.h>": {
                    "signature": "#include <glcd_ssd1306.h>",
                    "description": "Graphical LCD routines for the GCBASIC compiler"
                },
                "<glcd_ssd1306_twin.h>": {
                    "signature": "#include <glcd_ssd1306_twin.h>",
                    "description": "Graphical LCD routines for the GCBASIC compiler"
                },
                "<glcd_ssd1331.h>": {
                    "signature": "#include <glcd_ssd1331.h>",
                    "description": "Graphical LCD routines for the GCBASIC compiler"
                },
                "<glcd_ssd1351.h>": {
                    "signature": "#include <glcd_ssd1351.h>",
                    "description": "Graphical LCD routines for the GCBASIC compiler"
                },
                "<glcd_st7735.h>": {
                    "signature": "#include <glcd_st7735.h>",
                    "description": "Graphical LCD routines for the GCBASIC compiler"
                },
                "<glcd_st7735r.h>": {
                    "signature": "#include <glcd_st7735r.h>",
                    "description": "Graphical LCD routines for the GCBASIC compiler"
                },
                "<glcd_st7789.h>": {
                    "signature": "#include <glcd_st7789.h>",
                    "description": "Graphical LCD routines for the GCBASIC compiler"
                },
                "<glcd_st7920.h>": {
                    "signature": "#include <glcd_st7920.h>",
                    "description": "Graphical LCD routines for the GCBASIC compiler"
                },
                "<glcd_t6963.h>": {
                    "signature": "#include <glcd_t6963.h>",
                    "description": "Graphical LCD routines for the GCBASIC compiler"
                },
                "<glcd_uc1601.h>": {
                    "signature": "#include <glcd_uc1601.h>",
                    "description": "Graphical LCD routines for the GCBASIC compiler"
                },
                "<glcd_uc8230.h>": {
                    "signature": "#include <glcd_uc8230.h>",
                    "description": "Graphical LCD routines for the GCBASIC compiler"
                },
                "<glcd_xxxxxx.h>": {
                    "signature": "#include <glcd_xxxxxx.h>",
                    "description": "Graphical LCD routines for the GCBASIC compiler"
                },
                "<heflash_superceded.h>": {
                    "signature": "#include <heflash_superceded.h>",
                    "description": "GCB Library for reading/writing to High Endurance Flash Memory"
                },
                "<hmc5883l.h>": {
                    "signature": "#include <hmc5883l.h>",
                    "description": "HMC5883 routines for the GCBASIC compiler"
                },
                "<hwi2c_isr_handler.h>": {
                    "signature": "#include <hwi2c_isr_handler.h>",
                    "description": "A Hardware I2C ISR Handler for GCGB and GCB"
                },
                "<hwi2c_isr_handlerkmode.h>": {
                    "signature": "#include <hwi2c_isr_handlerkmode.h>",
                    "description": "A Hardware I2C ISR Handler for GCGB and GCB"
                },
                "<hwi2c_messageinterface.h>": {
                    "signature": "#include <hwi2c_messageinterface.h>",
                    "description": "An I2C Message Handler for GCGB and GCB"
                },
                "<hwi2c_messageinterfacekmode.h>": {
                    "signature": "#include <hwi2c_messageinterfacekmode.h>",
                    "description": "An I2C Message Handler for GCGB and GCB"
                },
                "<i2ceeprom.h>": {
                    "signature": "#include <i2ceeprom.h>",
                    "description": "Software I2C routines for the GCBASIC compiler"
                },
                "<lcd2serialredirect.h>": {
                    "signature": "#include <lcd2serialredirect.h>",
                    "description": " A redirector for LCD to a Serial Terminal"
                },
                "<lego.h>": {
                    "signature": "#include <lego.h>",
                    "description": "Lego Mindstorms interface routines for the GCBASIC compiler"
                },
                "<lego-pf.h>": {
                    "signature": "#include <lego-pf.h>",
                    "description": "Lego Power Functions IR interface routines for the GCBASIC compiler"
                },
                "<LGT8F328P.h>": {
                    "signature": "#include <LGT8F328P.h>",
                    "description": " Library to allow the Arduino Duemilanove (mega328) to work with GCBASIC"
                },
                "<lgt8fx8p.h>": {
                    "signature": "#include <lgt8fx8p.h>",
                    "description": "Library to allow the Arduino Duemilanove (mega328) to work with GCBASIC"
                },
                "<maths.h>": {
                    "signature": "#include <maths.h>",
                    "description": "Maths outines for the GCBASIC compiler"
                },
                "<max848xdigitalpot.h>": {
                    "signature": "#include <max848xdigitalpot.h>",
                    "description": "This program is for the Digital potentiometer 2.7 to 5.5V 7-bit linear digital potentiometer with SPI interface."
                },
                "<max6675.h>": {
                    "signature": "#include <max6675.h>",
                    "description": "k-type thermocouple to digital converter."
                },
                "<max7219_ledmatrix_driver.h>": {
                    "signature": "#include <max7219_ledmatrix_driver.h>",
                    "description": "Graphical Max7219 GLCD routines for the GCBASIC compiler"
                },
                "<mcp4xxxdigitalpot.h>": {
                    "signature": "#include <mcp4xxxdigitalpot.h>",
                    "description": "This program is for the Digital potentiometer 2.7 to 5.5V 7-bit linear digital potentiometer with SPI interface."
                },
                "<mcp7940n.h>": {
                    "signature": "#include <mcp7940n.h>",
                    "description": "Library for reading/writing to Microchip MCP7940N RTC for the GCBASIC compiler"
                },
                "<mcp23008.h>": {
                    "signature": "#include <mcp23008.h>",
                    "description": "Library for MCP23008 8bit IO Expander"
                },
                "<mcp23017.h>": {
                    "signature": "#include <mcp23017.h>",
                    "description": "MCP23017 Library for Great Cow BASIC Compiler"
                },
                "<mega2560.h>": {
                    "signature": "#include <mega2560.h>",
                    "description": "Library to allow the Arduino mega2560 to work with GCBASIC"
                },
                "<microchiprtcc.h>": {
                    "signature": "#include <microchiprtcc.h>",
                    "description": "Library for reading/writing to Microchip DS1337 RTC for the GCBASIC compiler"
                },
                "<millis.h>": {
                    "signature": "#include <millis.h>",
                    "description": "millis() function for Great Cow BASIC"
                },
                "<mtask.h>": {
                    "signature": "#include <cmtask.h>",
                    "description": "18F Multi tasking routines for the GCBASIC compiler"
                },
                "<mylcd.h>": {
                    "signature": "#include <mylcd.h>",
                    "description": "Liquid Crystal Display routines for Great Cow BASIC"
                },
                "<nunchuck.h>": {
                    "signature": "#include <nunchuck.h>",
                    "description": "A driver for GCGB and GCB"
                },
                "<cpca9685.h>": {
                    "signature": "#include <pca9685.h>",
                    "description": "PCA9685 routines for the GCBASIC compiler"
                },
                "<PCF85X3.h>": {
                    "signature": "#include <PCF85X3.h>",
                    "description": "Software PCF85x3 routines for the GCBASIC compiler"
                },
                "<pcf8574.h>": {
                    "signature": "#include <pcf8574.h>",
                    "description": "A suppport program  for GCGB and GCB"
                },
                "<sd.h>": {
                    "signature": "#include <sd.h>",
                    "description": "SD card routines for the GCBASIC compilere"
                },
                "<smt_timers.h>": {
                    "signature": "#include <smt_timers.h>",
                    "description": "PIC Signal Measurment Timer (SMT) routines for the GCBASIC compiler"
                },
                "<softserial.h>": {
                    "signature": "#include <softserial.h>",
                    "description": "MicroChip specific to support Software Serial for Great Cow BASIC"
                },
                "<softserialch1.h>": {
                    "signature": "#include <softserialch1.h>",
                    "description": "MicroChip specific to support Software Serial for Great Cow BASIC"
                },
                "<softserialch2.h>": {
                    "signature": "#include <softserialch2.h>",
                    "description": "MicroChip specific to support Software Serial for Great Cow BASIC"
                },
                "<softserialch3.h>": {
                    "signature": "#include <softserialch3.h>",
                    "description": "MicroChip specific to support Software Serial for Great Cow BASIC"
                },
                "<songplay.h>": {
                    "signature": "#include <songplay.h>",
                    "description": "Song playing routines for the GCBASIC compiler"
                },
                "<sonyremote.h>": {
                    "signature": "#include <sonyremote.h>",
                    "description": "Sony IR Remote Control Library for Great Cow Basic"
                },
                "<srf02.h>": {
                    "signature": "#include <srf02.h>",
                    "description": "Ultrasonic distance sensor routines for the GCBASIC compiler"
                },
                "<srf04.h>": {
                    "signature": "#include <srf04.h>",
                    "description": "Ultrasonic distance sensor routines for the GCBASIC compiler"
                },
                "<tea5767.h>": {
                    "signature": "#include <tea5767.h>",
                    "description": "TEA5767 routines for the GCBASIC compiler"
                },
                "<tm1637.h>": {
                    "signature": "#include <tm1637.h>",
                    "description": "7 Segment LED display routines using the TM1637  for Great Cow BASIC"
                },
                "<tm1637_6d.h>": {
                    "signature": "#include <tm1637_6d.h>",
                    "description": "Routines for 6 digit 7 Segment LED display RobotDyne module (and clones) using the TM1637 for Great Cow BASIC"
                },
                "<tm1637a.h>": {
                    "signature": "#include <tm1637a.h>",
                    "description": "7 Segment LED display routines using the TM1637  for Great Cow BASIC"
                },
                "<trig2places.h>": {
                    "signature": "#include <trig2places.h>",
                    "description": "Trigonometric Functions for Great Cow Basice"
                },
                "<trig3places.h>": {
                    "signature": "#include <trig3places.h>",
                    "description": "Trigonometric Functions for Great Cow Basice"
                },
                "<trig4places.h>": {
                    "signature": "#include <trig4places.h>",
                    "description": "Trigonometric Functions for Great Cow Basice"
                },
                "<uno_mega328p.h>": {
                    "signature": "#include <uno_mega328p.h>",
                    "description": " Library to allow the Arduino Duemilanove (mega328) to work with GCBASIC"
                },
                "<usb.h>": {
                    "signature": "#include <usb.h>",
                    "description": "USB routines for the GCBASIC compiler"
                },
                "<utils.h>": {
                    "signature": "#include <utils.h>",
                    "description": ""
                },
                "<xpt2046.h>": {
                    "signature": "#include <xpt2046.h>",
                    "description": "XPT2046 routines for the GCBASIC compiler"
                }
            },
            "extends": "",
            "accessor": "#include"
        },
        {
            "title": "Global Defines",
            "description": "This class contains all global #define Types",
            "funcs": {
                "AD_DELAY": {
                    "signature": "Analog/Digital Conversion",
                    "description": "The constant AD_Delay controls is the acquisition delay. This can be changed by adding the following constant.",
                    "value": "2 10US"
                },
                "AD_VREF_DELAY": {
                    "signature": "Analog/Digital Conversion",
                    "description": "controls the charging time for VRef capacitor on Atmel AVR microcontrollers only.This therefore controls the charge from internal VRef. ReadAD will not be accurate for internal reference without this.",
                    "value": "1 MS"
                },
                "ADSPEED": {
                    "signature": "Analog/Digital Conversion",
                    "description": "ADSpeed controls the source of the clock for the ADC module. It varies from one chip to another. InternalClock is a Microchip PIC microcontroller only option that will drive the ADC from an internal RC oscillator. |HighSpeed| MediumSpeed| LowSpeed|",
                    "value": "MEDIUMSPEED"
                },
                "AD_ACQUISITION_TIME_SELECT_BITS": {
                    "signature": "Analog/Digital Conversion",
                    "description": "Controls the Acquisition Time Select bits. Acquisition time is the duration that the AD charge holding capacitor remains connected to AD channel from the instant the read is commenced is set until conversions begins.",
                    "value": "4"
                },
                "AD_REF_SOURCE": {
                    "signature": "Analog/Digital Conversion",
                    "description": "To use a voltage reference source for ADC operation sett the AD_REF_SOURCE constant to your chosen source.",
                    "value": "AD_REF_AVCC"
                },
                "AD_REF_AREF": {
                    "signature": "Analog/Digital Conversion",
                    "description": "Extenal voltage reference source",
                    "value": "0"
                },
                "AD_REF_AVCC": {
                    "signature": "Analog/Digital Conversion",
                    "description": "VCC supplied Voltage",
                    "value": "1"
                },
                "AD_REF_256": {
                    "signature": "Analog/Digital Conversion",
                    "description": "AD_REF_256 for ATMegas",
                    "value": "3"
                },
                "AD_REF_4096": {
                    "signature": "Analog/Digital Conversion",
                    "description": "4.096v internal reference source",
                    "value": "4"
                },
                "AD_REF_2048": {
                    "signature": "Analog/Digital Conversion",
                    "description": "2.048v internal reference source",
                    "value": "5"
                },
                "AD_REF_1024": {
                    "signature": "Analog/Digital Conversion",
                    "description": "AD_REF_256 for ATMegas",
                    "value": "6"
                },
                "PWM_FREQ": {
                    "signature": "Pulse width modulation",
                    "description": "Specifies the output frequency of the PWM module in KHz.",
                    "value": "38"
                },
                "PWM_DUTY": {
                    "signature": "Pulse width modulation",
                    "description": "Sets the duty cycle of the PWM module output. Given as percentage.",
                    "value": "50"
                },
                "LCD_BACKLIGHT_ON_STATE": {
                    "signature": "Liquid Crystal Display",
                    "description": "Do not connect the LCD backlight directly to the microcontroller! Always refer to the datasheet for the correct method to drive the LCD backlight.",
                    "value": "1"
                },
                "LCD_BACKLIGHT_OFF_STATE": {
                    "signature": "Liquid Crystal Display",
                    "description": "Do not connect the LCD backlight directly to the microcontroller! Always refer to the datasheet for the correct method to drive the LCD backlight.",
                    "value": "0"
                },
                "LCD_I2C_ADDRESS_1": {
                    "signature": "Liquid Crystal Display",
                    "description": "Address of I2C adapter",
                    "value": "78"
                },
                "HI2CITSCLWaitPeriod": {
                    "signature": "I2C",
                    "description": "Sets the TSCL period to Zero as the Stop condition must be held for TSCL after Stop transition. Default to 70, some solutions can use this set to 0. The clock source and clock method must be reviewed before changing this setting.",
                    "value": "70"
                },
                "I2C_MODE": {
                    "signature": "I2C",
                    "description": "Mode of I2C routines (Master or Slave)",
                    "value": "MASTER"
                },
                "I2C_BIT_DELAY": {
                    "signature": "I2C",
                    "description": "Time for a bit (used for acknowledge detection)",
                    "value": "2 US"
                },
                "I2C_CLOCK_DELAY": {
                    "signature": "I2C",
                    "description": "Time for clock pulse to remain high",
                    "value": "1 US"
                },
                "I2C_END_DELAY": {
                    "signature": "I2C",
                    "description": "Time between clock pulses",
                    "value": "1 US"
                },
                "I2C_USE_TIMEOUT": {
                    "signature": "I2C",
                    "description": "Set to true if the I2C routines should stop waiting for the I2c bus - the routine will exit if a timeout occurs. Should be used when you need to prevent system lockups on the I2C bus."
                },
                "I2C_DISABLE_INTERRUPTS": {
                    "signature": "I2C",
                    "description": "Disable interrupts during I2C routines. Important when an i2C clock is part of your solution"
                },
                "I2C_DATA": {
                    "signature": "I2C",
                    "description": "Pin on microcontroller connected to I2C data"
                },
                "HI2C_BAUD_RATE": {
                    "signature": "I2C",
                    "description": "Operational speed of the microcontroller. Defaults to 100 kbit/s",
                    "value": "100"
                },
                "SoundOut": {
                    "signature": "Sound",
                    "description": "The output pin to produce sound on"
                },
                "LCD_IO": {
                    "signature": "Liquid Crystal Display",
                    "description": "The I/O mode.",
                    "value": "4"
                },
                "LCD_CD": {
                    "signature": "Liquid Crystal Display",
                    "description": "The clock/data pin used in 1-bit mode.",
                    "value": "SYSLCDTEMP.0"
                },
                "LCD_DB": {
                    "signature": "Liquid Crystal Display",
                    "description": "The data pin used in 2-bit mode.",
                    "value": "SYSLCDTEMP.0"
                },
                "LCD_CB": {
                    "signature": "Liquid Crystal Display",
                    "description": "The clock pin used in 2- bit mode.",
                    "value": "SYSLCDTEMP.0"
                },
                "LCD_EB": {
                    "signature": "Liquid Crystal Display",
                    "description": "The enable pin used in 3- bit mode."
                },
                "LCD_SPEED": {
                    "signature": "Liquid Crystal Display",
                    "description": "FAST, MEDIUM, SLOW or OPTIMAL.",
                    "value": "SLOW"
                },
                "LCD_RS": {
                    "signature": "Liquid Crystal Display",
                    "description": "Specifies the output pin that is connected to Register Select on the LCD.",
                    "value": "SYSLCDTEMP.1"
                },
                "LCD_RW": {
                    "signature": "Liquid Crystal Display",
                    "description": "Specifies the output pin that is connected to Read/Write on the LCD. The R/W pin can be disabled*.",
                    "value": "SYSLCDTEMP.0"
                },
                "LCD_Enable": {
                    "signature": "Liquid Crystal Display",
                    "description": "Specifies the output pin that is connected to Read/Write on the LCD.",
                    "value": "SYSLCDTEMP.0"
                },
                "LCD_DB4": {
                    "signature": "Liquid Crystal Display",
                    "description": "Output pin used to interface with bit 4 of the LCD data bus",
                    "value": "SYSLCDTEMP.0"
                },
                "LCD_DB5": {
                    "signature": "Liquid Crystal Display",
                    "description": "Output pin used to interface with bit 5 of the LCD data bus",
                    "value": "SYSLCDTEMP.0"
                },
                "LCD_DB6": {
                    "signature": "Liquid Crystal Display",
                    "description": "Output pin used to interface with bit 6 of the LCD data bus",
                    "value": "SYSLCDTEMP.0"
                },
                "LCD_DB7": {
                    "signature": "Liquid Crystal Display",
                    "description": "Output pin used to interface with bit 7 of the LCD data bus",
                    "value": "SYSLCDTEMP.0"
                },
                "LCD_VFD_DELAY": {
                    "signature": "Liquid Crystal Display",
                    "description": "Specifies a delay between transmission of data nibbles to LCD or VFD.",
                    "value": "2 US"
                },
                "LCD_DATA_PORT": {
                    "signature": "Liquid Crystal Display",
                    "description": "Output port used to interface with LCD data bus",
                    "value": "SYSLCDTEMP"
                },
                "LCD_LAT": {
                    "signature": "Liquid Crystal Display",
                    "description": "Drives the port with LATx support. Resolves issues with faster Mhz and the Microchip PIC read/write/modify feature. See example below."
                },
                "LCD_WIDTH": {
                    "signature": "Liquid Crystal Display",
                    "description": "This constant changes the width characteristics of a LCD display.",
                    "value": "20"
                },
                "USART_BAUD_RATE": {
                    "signature": "Serial Communications",
                    "description": "Baud rate (in bps) for the routines to operate at.",
                    "value": "115200"
                },
                "USART_BLOCKING": {
                    "signature": "Serial Communications",
                    "description": "If defined, this constant will cause the USART routines to wait until data can be sent or received."
                },
                "USART_BLOCKING_TIMEOUT": {
                    "signature": "Serial Communications",
                    "description": "If defined, this constant will cause the USART_BLOCKING to timeout receive after a defined time in milliseconds."
                },
                "USART_TX_BLOCKING": {
                    "signature": "Serial Communications",
                    "description": "If defined, this constant will cause the Transmit USART routines to wait until Transmit register is empty before writing the next byte which prevents over running the register and losing data."
                },
                "USART2_BAUD_RATE": {
                    "signature": "Serial Communications",
                    "description": "Baud rate (in bps) for the routines to operate at."
                },
                "USART2_BLOCKING": {
                    "signature": "Serial Communications",
                    "description": "If defined, this constant will cause the USART routines to wait until data can be sent or received."
                },
                "USART2_TX_BLOCKING": {
                    "signature": "Serial Communications",
                    "description": "If defined, this constant will cause the Transmit USART routines to wait until Transmit register is empty before writing the next byte which prevents over running the register and losing data."
                },
                "USART3_BAUD_RATE": {
                    "signature": "Serial Communications",
                    "description": "Baud rate (in bps) for the routines to operate at."
                },
                "USART3_BLOCKING": {
                    "signature": "Serial Communications",
                    "description": "If defined, this constant will cause the USART routines to wait until data can be sent or received."
                },
                "USART3_TX_BLOCKING": {
                    "signature": "Serial Communications",
                    "description": "If defined, this constant will cause the Transmit USART routines to wait until Transmit register is empty before writing the next byte which prevents over running the register and losing data."
                },
                "USART4_BAUD_RATE": {
                    "signature": "Serial Communications",
                    "description": "Baud rate (in bps) for the routines to operate at."
                },
                "USART4_BLOCKING": {
                    "signature": "Serial Communications",
                    "description": "If defined, this constant will cause the USART routines to wait until data can be sent or received."
                },
                "USART4_TX_BLOCKING": {
                    "signature": "Serial Communications",
                    "description": "If defined, this constant will cause the Transmit USART routines to wait until Transmit register is empty before writing the next byte which prevents over running the register and losing data."
                },
                "USART_DELAY": {
                    "signature": "Serial Communications",
                    "description": "This is the delay between characters.",
                    "value": "OFF"
                },
                "CHECK_USART_BAUD_RATE": {
                    "signature": "Serial Communications",
                    "description": "Instruct the compiler to show the real BPS to be used"
                },
                "SerPrintCR": {
                    "signature": "Serial Communications",
                    "description": "Causes a Carriage return to be sent after every HserPrint automatically."
                },
                "SerPrintLF": {
                    "signature": "Serial Communications",
                    "description": "Causes a LineFeed to be sent after every HserPrint. Some communications require both CR and LF"
                },
                "PS2Data": {
                    "signature": "PS/2",
                    "description": "Pin connected to PS/2 data line"
                },
                "PS2Clock": {
                    "signature": "PS/2",
                    "description": "Pin connected to PS/2 clock line."
                },
                "PS2_DELAY": {
                    "signature": "PS/2",
                    "description": "This constant can be set to a delay, such as 10 ms. If set, a delay will be added at the end of every byte sent or received."
                },
                "STOPCOMPILERERRORHANDLER": {
                    "signature": "RaiseCompilerError",
                    "description": "The RaiseCompilerError handler can be stopped using the constant STOPCOMPILERERRORHANDLER."
                },
                "HSerPrintLF1": {
                    "signature": "USART",
                    "description": "a Constant that will force the sending of a LF at the end of each USART transmission for USART1"
                },
                "HSerPrintCR1": {
                    "signature": "USART",
                    "description": "a Constant that will force the sending of a CR at the end of each USART transmission for USART1"
                },
                "HSerPrintLF2": {
                    "signature": "USART",
                    "description": "a Constant that will force the sending of a LF at the end of each USART transmission for USART2"
                },
                "HSerPrintCR2": {
                    "signature": "USART",
                    "description": "a Constant that will force the sending of a CR at the end of each USART transmission for USART2"
                },
                "HSerPrintLF3": {
                    "signature": "USART",
                    "description": "a Constant that will force the sending of a LF at the end of each USART transmission for USART3"
                },
                "HSerPrintCR3": {
                    "signature": "USART",
                    "description": "a Constant that will force the sending of a CR at the end of each USART transmission for USART3"
                },
                "HSerPrintLF4": {
                    "signature": "USART",
                    "description": "a Constant that will force the sending of a LF at the end of each USART transmission for USART4"
                },
                "HSerPrintCR4": {
                    "signature": "USART",
                    "description": "a Constant that will force the sending of a CR at the end of each USART transmission for USART4"
                },
                "HSerPrintLF5": {
                    "signature": "USART",
                    "description": "a Constant that will force the sending of a LF at the end of each USART transmission for USART5"
                },
                "HSerPrintCR5": {
                    "signature": "USART",
                    "description": "a Constant that will force the sending of a CR at the end of each USART transmission for USART5"
                }
            },
            "extends": "",
            "accessor": "#define"
        },
        {
            "title": "ADSPEED Types",
            "description": "This class contains all ADSPEED Types",
            "funcs": {
                "HighSpeed": {},
                "MediumSpeed": {},
                "LowSpeed": {}
            },
            "extends": "",
            "accessor": "adspeed"
        },
        {
            "title": "HI2C_BAUD_RATE Types",
            "description": "This class contains all HI2C_BAUD_RATE Types",
            "funcs": {
                "50": {},
                "100": {},
                "125": {},
                "400": {},
                "1000": {},
                "3200": {}
            },
            "extends": "",
            "accessor": "hi2c_baud_rate"
        },
        {
            "title": "I2C_Mode Types",
            "description": "This class contains all I2C_Mode Types",
            "funcs": {
                "Master": {},
                "Slave": {}
            },
            "extends": "",
            "accessor": "i2c_mode"
        },
        {
            "title": "LCD_IO Types",
            "description": "This class contains all LCD_IO Types",
            "funcs": {
                "0": {
                    "signature": "LCD_IO",
                    "description": "No configuration is required directly by this method. The LCD routines must be provided with other subroutines which will handle the communication. This is useful for communicating with LCDs connected through RS232 or I2C. \n\nThis is an advanced method of driving an LCD"
                },
                "1": {
                    "signature": "LCD_IO",
                    "description": "Uses a combined data and clock line. This mode is used when the LCD is connected through a shift register 74HC595"
                },
                "2": {
                    "signature": "LCD_IO",
                    "description": "Uses separated Data and Clock lines. This mode is used when the LCD is connected through a 74LS174 shift register IC"
                },
                "3": {
                    "signature": "LCD_IO",
                    "description": "DB, CB, EB are connected to the microcontroller as the Data, Clock and Enable Bits."
                },
                "4": {
                    "signature": "LCD_IO",
                    "description": "R/W, RS, Enable and the highest 4 data lines (DB4 through DB7) are connected to the microcontroller. The use of the R/W line is optional."
                },
                "8": {
                    "signature": "LCD_IO",
                    "description": "R/W, RS, Enable and all 8 data lines. The data lines must all be connected to the same I/O port, in sequential order. For example, DB0 to PORTB.0, DB1 to PORTB.1 and so on, with`DB7` going to PORTB.7."
                },
                "10": {
                    "signature": "LCD_IO",
                    "description": "The LCD is controlled via I2C. A type 10 LCD 12C adapter. Set LCD_IO to 10 for the YwRobot LCD1602 IIC V1 or the Sainsmart LCD_PIC I2C adapter"
                },
                "12": {
                    "signature": "LCD_IO",
                    "description": "The LCD is controlled via I2C. A type 12 LCD 12C adapter. Set LCD_IO to `12`for the Ywmjkdz I2C adapter with a potentiometer (variable resistance) bent over top of chip."
                },
                "107": {
                    "signature": "LCD_IO",
                    "description": "The LCD is controlled via serial. Set LCD_IO to 107 or K107"
                }
            },
            "extends": "",
            "accessor": "lcd_io"
        },
        {
            "title": "LCD_SPEED Types",
            "description": "This class contains all LCD_SPEED Types",
            "funcs": {
                "Optimal": {},
                "Fast": {},
                "Medium": {},
                "Slow": {}
            },
            "extends": "",
            "accessor": "lcd_speed"
        },
        {
            "title": "USART_BAUD_RATE Types",
            "description": "This class contains all USART_BAUD_RATE Types",
            "funcs": {
                "75": {},
                "110": {},
                "134": {},
                "150": {},
                "300": {},
                "600": {},
                "1200": {},
                "1800": {},
                "2400": {},
                "4800": {},
                "7200": {},
                "9600": {},
                "14400": {},
                "19200": {},
                "38400": {},
                "57600": {},
                "115200": {},
                "128000": {}
            },
            "extends": "",
            "accessor": "usart_baud_rate"
        },
        {
            "title": "USART2_BAUD_RATE Types",
            "description": "This class contains all USART2_BAUD_RATE Types",
            "funcs": {
                "75": {},
                "110": {},
                "134": {},
                "150": {},
                "300": {},
                "600": {},
                "1200": {},
                "1800": {},
                "2400": {},
                "4800": {},
                "7200": {},
                "9600": {},
                "14400": {},
                "19200": {},
                "38400": {},
                "57600": {},
                "115200": {},
                "128000": {}
            },
            "extends": "",
            "accessor": "usart2_baud_rate"
        },
        {
            "title": "USART3_BAUD_RATE Types",
            "description": "This class contains all USART3_BAUD_RATE Types",
            "funcs": {
                "75": {},
                "110": {},
                "134": {},
                "150": {},
                "300": {},
                "600": {},
                "1200": {},
                "1800": {},
                "2400": {},
                "4800": {},
                "7200": {},
                "9600": {},
                "14400": {},
                "19200": {},
                "38400": {},
                "57600": {},
                "115200": {},
                "128000": {}
            },
            "extends": "",
            "accessor": "usart3_baud_rate"
        },
        {
            "title": "USART4_BAUD_RATE Types",
            "description": "This class contains all USART4_BAUD_RATE Types",
            "funcs": {
                "75": {},
                "110": {},
                "134": {},
                "150": {},
                "300": {},
                "600": {},
                "1200": {},
                "1800": {},
                "2400": {},
                "4800": {},
                "7200": {},
                "9600": {},
                "14400": {},
                "19200": {},
                "38400": {},
                "57600": {},
                "115200": {},
                "128000": {}
            },
            "extends": "",
            "accessor": "usart4_baud_rate"
        },
        {
            "title": "SPI Modes",
            "description": "This class contains all SPI Modes",
            "funcs": {
                "(MasterSlow)": {
                    "signature": "SPIMode (Mode)",
                    "description": "Master mode, SPI clock is 1/64 of the frequency of the microcontroller."
                },
                "(Master)": {
                    "signature": "SPIMode (Mode)",
                    "description": "Master mode, SPI clock is 1/16 of the frequency of the microcontroller."
                },
                "(MasterFast)": {
                    "signature": "SPIMode (Mode)",
                    "description": "Master mode, SPI clock is 1/4 of the frequency of the microcontroller."
                },
                "(Slave)": {
                    "signature": "SPIMode (Mode)",
                    "description": "Master mode, SPI clock is 1/64 of the frequency of the microcontroller."
                },
                "(SlaveSS)": {
                    "signature": "SPIMode (Mode)",
                    "description": "Slave mode, with the Slave Select pin enabled."
                },
                "(MasterSlow, SPI_CPOL_0 + SPI_CPHA_0)": {
                    "signature": "SPIMode (Mode)",
                    "description": "Master mode, SPI clock is 1/64 of the frequency of the microcontroller. SPI_CPOL = 0 & SPI_CPHA = 0"
                },
                "(Master, SPI_CPOL_0 + SPI_CPHA_0)": {
                    "signature": "SPIMode (Mode)",
                    "description": "Master mode, SPI clock is 1/16 of the frequency of the microcontroller. SPI_CPOL = 0 & SPI_CPHA = 0"
                },
                "(MasterFast, SPI_CPOL_0 + SPI_CPHA_0)": {
                    "signature": "SPIMode (Mode)",
                    "description": "Master mode, SPI clock is 1/4 of the frequency of the microcontroller. SPI_CPOL = 0 & SPI_CPHA = 0"
                },
                "(Slave, SPI_CPOL_0 + SPI_CPHA_0)": {
                    "signature": "SPIMode (Mode)",
                    "description": "Master mode, SPI clock is 1/64 of the frequency of the microcontroller. SPI_CPOL = 0 & SPI_CPHA = 0"
                },
                "(SlaveSS, SPI_CPOL_0 + SPI_CPHA_0)": {
                    "signature": "SPIMode (Mode)",
                    "description": "Slave mode, with the Slave Select pin enabled. SPI_CPOL = 0 & SPI_CPHA = 0"
                },
                "(MasterSlow, SPI_CPOL_0 + SPI_CPHA_1)": {
                    "signature": "SPIMode (Mode)",
                    "description": "Master mode, SPI clock is 1/64 of the frequency of the microcontroller. SPI_CPOL = 0 & SPI_CPHA = 1"
                },
                "(Master, SPI_CPOL_0 + SPI_CPHA_1)": {
                    "signature": "SPIMode (Mode)",
                    "description": "Master mode, SPI clock is 1/16 of the frequency of the microcontroller. SPI_CPOL = 0 & SPI_CPHA = 1"
                },
                "(MasterFast, SPI_CPOL_0 + SPI_CPHA_1)": {
                    "signature": "SPIMode (Mode)",
                    "description": "Master mode, SPI clock is 1/4 of the frequency of the microcontroller. SPI_CPOL = 0 & SPI_CPHA = 1"
                },
                "(Slave, SPI_CPOL_0 + SPI_CPHA_1)": {
                    "signature": "SPIMode (Mode)",
                    "description": "Master mode, SPI clock is 1/64 of the frequency of the microcontroller. SPI_CPOL = 0 & SPI_CPHA = 1"
                },
                "(SlaveSS, SPI_CPOL_0 + SPI_CPHA_1)": {
                    "signature": "SPIMode (Mode)",
                    "description": "Slave mode, with the Slave Select pin enabled. SPI_CPOL = 0 & SPI_CPHA = 1"
                },
                "(MasterSlow, SPI_CPOL_1 + SPI_CPHA_0)": {
                    "signature": "SPIMode (Mode)",
                    "description": "Master mode, SPI clock is 1/64 of the frequency of the microcontroller. SPI_CPOL = 1 & SPI_CPHA = 0"
                },
                "(Master, SPI_CPOL_1 + SPI_CPHA_0)": {
                    "signature": "SPIMode (Mode)",
                    "description": "Master mode, SPI clock is 1/16 of the frequency of the microcontroller. SPI_CPOL = 1 & SPI_CPHA = 0"
                },
                "(MasterFast, SPI_CPOL_1 + SPI_CPHA_0)": {
                    "signature": "SPIMode (Mode)",
                    "description": "Master mode, SPI clock is 1/4 of the frequency of the microcontroller. SPI_CPOL = 1 & SPI_CPHA = 0"
                },
                "(Slave, SPI_CPOL_1 + SPI_CPHA_0)": {
                    "signature": "SPIMode (Mode)",
                    "description": "Master mode, SPI clock is 1/64 of the frequency of the microcontroller. SPI_CPOL = 1 & SPI_CPHA = 0"
                },
                "(SlaveSS, SPI_CPOL_1 + SPI_CPHA_0)": {
                    "signature": "SPIMode (Mode)",
                    "description": "Slave mode, with the Slave Select pin enabled. SPI_CPOL = 1 & SPI_CPHA = 0"
                },
                "(MasterSlow, SPI_CPOL_1 + SPI_CPHA_1)": {
                    "signature": "SPIMode (Mode)",
                    "description": "Master mode, SPI clock is 1/64 of the frequency of the microcontroller. SPI_CPOL = 1 & SPI_CPHA = 1"
                },
                "(Master, SPI_CPOL_1 + SPI_CPHA_1)": {
                    "signature": "SPIMode (Mode)",
                    "description": "Master mode, SPI clock is 1/16 of the frequency of the microcontroller. SPI_CPOL = 1 & SPI_CPHA = 1"
                },
                "(MasterFast, SPI_CPOL_1 + SPI_CPHA_1)": {
                    "signature": "SPIMode (Mode)",
                    "description": "Master mode, SPI clock is 1/4 of the frequency of the microcontroller. SPI_CPOL = 1 & SPI_CPHA = 1"
                },
                "(Slave, SPI_CPOL_1 + SPI_CPHA_1)": {
                    "signature": "SPIMode (Mode)",
                    "description": "Master mode, SPI clock is 1/64 of the frequency of the microcontroller. SPI_CPOL = 1 & SPI_CPHA = 1"
                },
                "(SlaveSS, SPI_CPOL_1 + SPI_CPHA_1)": {
                    "signature": "SPIMode (Mode)",
                    "description": "Slave mode, with the Slave Select pin enabled. SPI_CPOL = 1 & SPI_CPHA = 1"
                }
            },
            "extends": "",
            "accessor": "spimode"
        },
        {
            "title": "SPI2 Modes",
            "description": "This class contains all SPI Modes",
            "funcs": {
                "(MasterSlow)": {
                    "signature": "SPI2Mode (Mode)",
                    "description": "Master mode, SPI clock is 1/64 of the frequency of the microcontroller."
                },
                "(Master)": {
                    "signature": "SPI2Mode (Mode)",
                    "description": "Master mode, SPI clock is 1/16 of the frequency of the microcontroller."
                },
                "(MasterFast)": {
                    "signature": "SPI2Mode (Mode)",
                    "description": "Master mode, SPI clock is 1/4 of the frequency of the microcontroller."
                },
                "(Slave)": {
                    "signature": "SPI2Mode (Mode)",
                    "description": "Master mode, SPI clock is 1/64 of the frequency of the microcontroller."
                },
                "(SlaveSS)": {
                    "signature": "SPI2Mode (Mode)",
                    "description": "Slave mode, with the Slave Select pin enabled."
                },
                "(MasterSlow, SPI_CPOL_0 + SPI_CPHA_0)": {
                    "signature": "SPI2Mode (Mode)",
                    "description": "Master mode, SPI clock is 1/64 of the frequency of the microcontroller. SPI_CPOL = 0 & SPI_CPHA = 0"
                },
                "(Master, SPI_CPOL_0 + SPI_CPHA_0)": {
                    "signature": "SPI2Mode (Mode)",
                    "description": "Master mode, SPI clock is 1/16 of the frequency of the microcontroller. SPI_CPOL = 0 & SPI_CPHA = 0"
                },
                "(MasterFast, SPI_CPOL_0 + SPI_CPHA_0)": {
                    "signature": "SPI2Mode (Mode)",
                    "description": "Master mode, SPI clock is 1/4 of the frequency of the microcontroller. SPI_CPOL = 0 & SPI_CPHA = 0"
                },
                "(Slave, SPI_CPOL_0 + SPI_CPHA_0)": {
                    "signature": "SPI2Mode (Mode)",
                    "description": "Master mode, SPI clock is 1/64 of the frequency of the microcontroller. SPI_CPOL = 0 & SPI_CPHA = 0"
                },
                "(SlaveSS, SPI_CPOL_0 + SPI_CPHA_0)": {
                    "signature": "SPI2Mode (Mode)",
                    "description": "Slave mode, with the Slave Select pin enabled. SPI_CPOL = 0 & SPI_CPHA = 0"
                },
                "(MasterSlow, SPI_CPOL_0 + SPI_CPHA_1)": {
                    "signature": "SPI2Mode (Mode)",
                    "description": "Master mode, SPI clock is 1/64 of the frequency of the microcontroller. SPI_CPOL = 0 & SPI_CPHA = 1"
                },
                "(Master, SPI_CPOL_0 + SPI_CPHA_1)": {
                    "signature": "SPI2Mode (Mode)",
                    "description": "Master mode, SPI clock is 1/16 of the frequency of the microcontroller. SPI_CPOL = 0 & SPI_CPHA = 1"
                },
                "(MasterFast, SPI_CPOL_0 + SPI_CPHA_1)": {
                    "signature": "SPI2Mode (Mode)",
                    "description": "Master mode, SPI clock is 1/4 of the frequency of the microcontroller. SPI_CPOL = 0 & SPI_CPHA = 1"
                },
                "(Slave, SPI_CPOL_0 + SPI_CPHA_1)": {
                    "signature": "SPI2Mode (Mode)",
                    "description": "Master mode, SPI clock is 1/64 of the frequency of the microcontroller. SPI_CPOL = 0 & SPI_CPHA = 1"
                },
                "(SlaveSS, SPI_CPOL_0 + SPI_CPHA_1)": {
                    "signature": "SPI2Mode (Mode)",
                    "description": "Slave mode, with the Slave Select pin enabled. SPI_CPOL = 0 & SPI_CPHA = 1"
                },
                "(MasterSlow, SPI_CPOL_1 + SPI_CPHA_0)": {
                    "signature": "SPI2Mode (Mode)",
                    "description": "Master mode, SPI clock is 1/64 of the frequency of the microcontroller. SPI_CPOL = 1 & SPI_CPHA = 0"
                },
                "(Master, SPI_CPOL_1 + SPI_CPHA_0)": {
                    "signature": "SPI2Mode (Mode)",
                    "description": "Master mode, SPI clock is 1/16 of the frequency of the microcontroller. SPI_CPOL = 1 & SPI_CPHA = 0"
                },
                "(MasterFast, SPI_CPOL_1 + SPI_CPHA_0)": {
                    "signature": "SPI2Mode (Mode)",
                    "description": "Master mode, SPI clock is 1/4 of the frequency of the microcontroller. SPI_CPOL = 1 & SPI_CPHA = 0"
                },
                "(Slave, SPI_CPOL_1 + SPI_CPHA_0)": {
                    "signature": "SPI2Mode (Mode)",
                    "description": "Master mode, SPI clock is 1/64 of the frequency of the microcontroller. SPI_CPOL = 1 & SPI_CPHA = 0"
                },
                "(SlaveSS, SPI_CPOL_1 + SPI_CPHA_0)": {
                    "signature": "SPI2Mode (Mode)",
                    "description": "Slave mode, with the Slave Select pin enabled. SPI_CPOL = 1 & SPI_CPHA = 0"
                },
                "(MasterSlow, SPI_CPOL_1 + SPI_CPHA_1)": {
                    "signature": "SPI2Mode (Mode)",
                    "description": "Master mode, SPI clock is 1/64 of the frequency of the microcontroller. SPI_CPOL = 1 & SPI_CPHA = 1"
                },
                "(Master, SPI_CPOL_1 + SPI_CPHA_1)": {
                    "signature": "SPI2Mode (Mode)",
                    "description": "Master mode, SPI clock is 1/16 of the frequency of the microcontroller. SPI_CPOL = 1 & SPI_CPHA = 1"
                },
                "(MasterFast, SPI_CPOL_1 + SPI_CPHA_1)": {
                    "signature": "SPI2Mode (Mode)",
                    "description": "Master mode, SPI clock is 1/4 of the frequency of the microcontroller. SPI_CPOL = 1 & SPI_CPHA = 1"
                },
                "(Slave, SPI_CPOL_1 + SPI_CPHA_1)": {
                    "signature": "SPI2Mode (Mode)",
                    "description": "Master mode, SPI clock is 1/64 of the frequency of the microcontroller. SPI_CPOL = 1 & SPI_CPHA = 1"
                },
                "(SlaveSS, SPI_CPOL_1 + SPI_CPHA_1)": {
                    "signature": "SPI2Mode (Mode)",
                    "description": "Slave mode, with the Slave Select pin enabled. SPI_CPOL = 1 & SPI_CPHA = 1"
                }
            },
            "extends": "",
            "accessor": "spi2mode"
        }        
    ],
    "directives": [
        {
            "title": "GCB Directives",
            "prefix": "GCB_Directives",
            "description": "General GCB Directives",
            "values": [
                {
                    "name": "chip",
                    "description": "#chip model, frequency",
                    "funcdesc": "The #chip directive is used to specify the chip model and frequency that Great Cow BASIC will use. The model is the specific microcontroller - examples are \"16F819\". The frequency is the frequency of the chip in MHz, and is required for the delay and PWM routines. The following constants simplify setting specific frequencies. 31k, 32.768K, 125k, 250k or 500k. Any of these constant can be used. As shown in the example below. If frequency is not present the compiler will select a frequency default frequency that should work for the microcontroller."
                },
                {
                    "name": "define",
                    "description": "#define Symbol Body",
                    "funcdesc": "#DEFINE allows to declare text-based preprocessor symbols.\n\nOnce the compiler has seen a #DEFINE, it will start replacing further occurrences of symbol with body.    Body may be empty.   The expansion is done recursively, until there is nothing more to expand and the compiler can continue analyzing the resulting code. \n #UNDEFINE can be used to make the compiler forget about a #DEFINE."
                },
                {
                    "name": "undefine",
                    "description": "#undefine existing-symbol",
                    "funcdesc": "#UNDEFINE Undefines a symbol previously defined with #DEFINE.\n\nCan be used to ensure that a symbol has a limited lifespan and does not conflict with a similar macro definition that may be defined later in the source code.\n\n(Note: #UNDEFINE should not be used to undefine variable or function names used in the current program. The names are needed internally by the compiler and removing them can cause strange and unexpected results.)"
                },
                {
                    "name": "config",
                    "description": "#config option1, option2, ... , optionN",
                    "funcdesc": "The #config directive is used to specify configuration options for the chip.\nThere is a detailed explanation of #config in the Configuration section of help."
                },
                {
                    "name": "include",
                    "description": "#include filename",
                    "funcdesc": "#include tells Great Cow BASIC to open up another file, read all of the subroutines and constants from it, and then copy them into the current program."
                },
                {
                    "name": "asmraw",
                    "description": "#asmraw [label]",
                    "funcdesc": "The #asmraw directive is used to specify the assembly that Great Cow BASIC will use.\nAnything following this directive will be inserted into ASM source file with no changes other than trimming spaces - no replacement of constants."
                },
                {
                    "name": "if",
                    "description": "#if Condition",
                    "funcdesc": "The #if directive is used to prevent a section of code from compiling unless Condition is true.\nCondition has the same syntax as the condition in a normal Great Cow BASIC if command. The only difference is that it uses constants instead of variables and does not use \"then\"."
                },
                {
                    "name": "ifnot",
                    "description": "#ifnot Condition",
                    "funcdesc": "The #ifnot directive is used to prevent a section of code from compiling unless Condition is false.\nCondition has the same syntax as the condition in a normal Great Cow BASIC if command. The only difference is that it uses constants instead of variables and does not use \"then\"."
                },
                {
                    "name": "insert",
                    "description": "#insert filename",
                    "funcdesc": "#insert` tells Great Cow BASIC to open up another file, read all of the subroutines and constants from it, and then copy them into the current program at the specific line where the #insert directive is located."
                },
                {
                    "name": "endif",
                    "description": "#endif",
                    "funcdesc": "The #endif directive is used to end #if, #ifdef and #ifndef directives."
                },
                {
                    "name": "ifdef",
                    "description": "#ifdef Constant | Constant Value | Var(VariableName)",
                    "funcdesc": "The #chip directive is used to specify the chip model and frequency that Great Cow BASIC will use. The model is the specific microcontroller - examples are \"16F819\". The frequency is the frequency of the chip in MHz, and is required for the delay and PWM routines. The following constants simplify setting specific frequencies. 31k, 32.768K, 125k, 250k or 500k. Any of these constant can be used. As shown in the example below. If frequency is not present the compiler will select a frequency default frequency that should work for the microcontroller."
                },
                {
                    "name": "ifndef",
                    "description": "#ifndef Constant | Constant Value | Var(VariableName)",
                    "funcdesc": "The #ifndef directive is used to selectively enable sections of code. It is the opposite of the #ifdef directive - it will delete code in cases where #ifdef would leave it, and will leave code where #ifdef would delete it."
                },
                {
                    "name": "else",
                    "description": "#else",
                    "funcdesc": "Else is used, then the condition between If and Else will run if the condition is true, and the code between Else and End If will run if the condition is false."
                },
                {
                    "name": "script",
                    "description": "#script",
                    "funcdesc": "The #script block is used to create small sections of code which Great Cow BASIC runs during compilation. A detail explanation and example are included in the Scripts article."
                },
                {
                    "name": "endscript",
                    "description": "#endscript",
                    "funcdesc": "The #endscript directive is used to end #script directive."
                },
                {
                    "name": "startup",
                    "description": "#startup SubName  [priority]",
                    "funcdesc": "#startup is used in include files to automatically insert initialization routines. If a define or subroutine from the file is used in the program, then the specified subroutine will be called.\n\nThe priority to #startup support the setting of the priority of the subroutines for all the libraries in a project.\n\nSubroutines will be called in order from smallest to largest priority number.\n\nInitSys has priority 80, lowlevel communication routines have the priority of 90\n\nAll other subroutines defaults to 100."
                },
                {
                    "name": "option Explicit",
                    "description": "#option explicit",
                    "funcdesc": "This option ensures that all variables are dimensioned in the user program. The scope is the user code only and no other code space like .h or include files.\n\n#option explicit requires all variables,including bytes, in the user program to be defined.\n\nVariables can be defined and not used within your user program. Unused variables will not allocate memory."
                },
                {
                    "name": "option NoConfig",
                    "description": "#option NoConfig",
                    "funcdesc": "This option will prevent the generated assembler from generating _Config items.\n#option NoConfig is used when using a bootloader"
                },
                {
                    "name": "option Bootloader",
                    "description": "#option bootloader address",
                    "funcdesc": "#option bootloader prevents the overwriting of any pre-loaded bootloader code, vectors, etc. below the specified address. The Great Cow BASIC code will start at specified address.\n\nA bootloader is a program that stays in the microcontroller and communicates with the PC, typically through the serial interface. The bootloader receives a user program from the PC and writes it in the flash memory, then launches this program in execution. Bootloaders can only be used with those microcontrollers that can write their flash memory through software.\n\nThe bootloader itself must be written into the flash memory with an external programmer.\nIn order for the bootloader to be launched after each reset, a goto bootloader instruction must exist somewhere in the first 4 instructions; There are two types of bootloaders, some that require that the user reallocate the code and others that by themselves reallocate the first 4 instructions of the user program to another location and execute them when the bootloader exits."
                },
                {
                    "name": "option NoContextSave",
                    "description": "#option NoContextSave",
                    "funcdesc": "Interrupts can occur at almost any time, and may interrupt another command as it runs. To ensure that the interrupted command can continue properly after the interrupt, some temporary variables (the context) must be saved. Normally Great Cow BASIC will do this automatically, but in some cases it may be necessary to prevent this. If porting some existing assembly code to Great Cow BASIC, or creating a bootloader using Great Cow BASIC that will call another program.\n\nNoContextSave can be used to prevent the context saving code from being added automatically."
                },
                {
                    "name": "option NoLatch",
                    "description": "#option NoLatch",
                    "funcdesc": "This option disables PORTx to LATx redirection."
                },
                {
                    "name": "option REQUIRED",
                    "description": "#option REQUIRED PIC|AVR CONSTANT \"Message string\"",
                    "funcdesc": "This option ensure that the specific CONSTANT exists within a library to ensure a specific capability is available with the microcontroller."
                },
                {
                    "name": "option Volatile",
                    "description": "#option Volatile `bit`",
                    "funcdesc": "This option ensure port setting are glitch-free."
                },
                {
                    "name": "option ReserveHighProg",
                    "description": "#option ReserveHighProg [words]",
                    "funcdesc": "This option reserves program memory to be kept free at the top end of memory.  This useful for HEF/SAF or bootloaders.\n\nThe option provided a reservation for the memory region that is normally assumed to be available to the compiler for the application code storage. In order to avoid any possible conflict (overlapping code and data usage), it is important to reserve the devices pecific memory range by using the compiler option (shown above) in the project configuration.\n\nUsing the #option ReserveHighProg [words] exposes the constant `ChipReserveHighProg in the user program."
                },
                {
                    "name": "IgnoreCompilation",
                    "description": "#IgnoreCompilation",
                    "funcdesc": "IgnoreCompilation is used to prevent a source file from compiling."
                }
            ]
        }
    ],
    "commands": [
        {
            "title": "GCB Commands",
            "prefix": "GCB_Commands",
            "description": "General GCB Commands",
            "values": [
                {
                    "name": "As",
                    "available": "All Microcontrollers",
                    "description": "Dim variable As type",
                    "funcdesc": "Defines a Variable Type"
                },
                {
                    "name": "Dim",
                    "available": "All Microcontrollers",
                    "description": "Dim variable[, variable2 [, variable3]] [As type] [Alias othervar [, othervar2]]",
                    "funcdesc": "The Dim variable command is used to instruct Great Cow BASIC to allocate variables or to create alternate names for existing variables (using Alias) or to create variables at a specific memory location (using At)."
                },
                {
                    "name": "ReadTable",
                    "available": "All Microcontrollers",
                    "description": "ReadTable TableName, Item, Output",
                    "funcdesc": "The ReadTable command is used to read information from lookup tables. TableName is the name of the table that is to be read, Item is the line of the table to read, and Output is the variable to write the retrieved value in to."
                },
                {
                    "name": "Table",
                    "available": "All Microcontrollers",
                    "description": "Table TableName as [Byte | Word | Integer | Long ]",
                    "funcdesc": "A lookup table is a list of values that are stored in the memory of the microcontroller, which then can be accessed using the ReadTable command."
                },
                {
                    "name": "Enum",
                    "available": "All Microcontrollers",
                    "description": "Enum EnumerationName [Reset]",
                    "funcdesc": "ENUM provide a convenient way to define named constants, improving code readability and maintainability. Instead of using raw numeric values, users can define meaningful names for states, modes, or categories"
                },
                {
                    "name": "Sub",
                    "available": "All Microcontrollers",
                    "description": "sub SubName(Var1, Var2, varEtc)",
                    "funcdesc": "A subroutine is a small program inside of the main program. Subroutines are typically used when a task needs to be repeated several times in different parts of the main program."
                },
                {
                    "name": "Function",
                    "available": "All Microcontrollers",
                    "description": "Function FuncName",
                    "funcdesc": "Functions are a special type of subroutine that can return a value. This means that when the name of the function is used in the place of a variable, Great Cow BASIC will call the function, get a value from it, and then put the value into the line of code in the place of the variable.\n\nFunctions may also have parameters - these are treated in exactly the same way as parameters for subroutines. The only exception is that brackets are required around any parameters when calling a function."
                },
                {
                    "name": "SPIMode",
                    "available": "Microchip PIC",
                    "description": "SPIMode ( Mode [, SPIClockMode])",
                    "funcdesc": "Mode sets the mode of the SPI module within the microcontroller. These are the possible SPI Modes: \n\nMasterSlow| Master mode, SPI clock is 1/64 of the frequency of the microcontroller.\nMaster| Master mode, SPI clock is 1/16 of the frequency of the microcontroller.\nMasterFast| Master mode, SPI clock is 1/4 of the frequency of the microcontroller.\nSlave| Slave mode.\nSlaveSS| Slave mode, with the Slave Select pin enabled.\n\nSPIClockMode is an optional parameter to set the mode of the SPI clock mode. This optional parameter sets both the clock polarity and clock edge.\n\n0| SPI_CPOL = 0 & SPI_CPHA = 0\n1| SPI_CPOL = 0 & SPI_CPHA = 1\n2| SPI_CPOL = 1 & SPI_CPHA = 0\n3| SPI_CPOL = 1 & SPI_CPHA = 1\n"
                },
                {
                    "name": "SPITransfer",
                    "available": "Microchip PIC",
                    "description": "SPIMode tx, rx",
                    "funcdesc": "This command simultaneously sends and receives a byte of data using the SPI protocol. It behaves differently depending on whether the microcontroller has been set to act as a master or a slave. When operating as a master, SPITransfer will initiate a transfer. The data in tx will be sent to the slave, whilst the byte that is buffered in the slave will be read into rx. In slave mode, the SPITransfer command will pause the program until a transfer is initiated by the master. At this point, it will send the data in tx whilst reading the transmission from the master into the rx variable."
                },
                {
                    "name": "FastHWSPITransfer",
                    "available": "Microchip PIC",
                    "description": "FastHWSPITransfer tx",
                    "funcdesc": "This command only sends a byte of data using the SPI protocol. This command only supports master mode.\nAs a master, FastHWSPITransfer will initiate a transfer. The data in tx will be sent to the slave."
                },
                {
                    "name": "SPI2Mode",
                    "available": "Microchip PIC",
                    "description": "SPI2Mode ( Mode [, SPIClockMode])",
                    "funcdesc": "Mode sets the mode of the SPI module within the microcontroller. These are the possible SPI Modes: \n\nMasterSlow| Master mode, SPI clock is 1/64 of the frequency of the microcontroller.\nMaster| Master mode, SPI clock is 1/16 of the frequency of the microcontroller.\nMasterFast| Master mode, SPI clock is 1/4 of the frequency of the microcontroller.\nSlave| Slave mode.\nSlaveSS| Slave mode, with the Slave Select pin enabled.\n\nSPIClockMode is an optional parameter to set the mode of the SPI clock mode. This optional parameter sets both the clock polarity and clock edge.\n\n0| SPI_CPOL = 0 & SPI_CPHA = 0\n1| SPI_CPOL = 0 & SPI_CPHA = 1\n2| SPI_CPOL = 1 & SPI_CPHA = 0\n3| SPI_CPOL = 1 & SPI_CPHA = 1\n"
                },
                {
                    "name": "SPI2Transfer",
                    "available": "Microchip PIC",
                    "description": "SPI2Mode tx, rx",
                    "funcdesc": "This command simultaneously sends and receives a byte of data using the SPI protocol. It behaves differently depending on whether the microcontroller has been set to act as a master or a slave. When operating as a master, SPITransfer will initiate a transfer. The data in tx will be sent to the slave, whilst the byte that is buffered in the slave will be read into rx. In slave mode, the SPITransfer command will pause the program until a transfer is initiated by the master. At this point, it will send the data in tx whilst reading the transmission from the master into the rx variable."
                },
                {
                    "name": "FastHWSPI2Transfer",
                    "available": "Microchip PIC",
                    "description": "FastHWSPI2Transfer tx",
                    "funcdesc": "This command only sends a byte of data using the SPI protocol. This command only supports master mode.\nAs a master, FastHWSPITransfer will initiate a transfer. The data in tx will be sent to the slave."
                },                
                {
                    "name": "ReadAD",
                    "available": "All Microcontrollers",
                    "description": "byte_variable = ReadAD( ANX )",
                    "funcdesc": "ReadAD is a function that can be used to read the built-in analog to digital converter that many microcontroller chips include.  port should be specified as AN0, AN1, AN2, etc. or ANA0, ANA1, ANA2, etc., up to the number of analog inputs available on the chip that is in use.  Those familiar with Atmel AVR microcontrollers can also refer to the ports as ADC0, ADC1, etc.  Refer to the datasheet for the microcontroller chip to find the number of ports available.  (Note: its perfectly acceptable to use ANx on AVR, or ADCx on the microcontroller)"
                },
                {
                    "name": "ReadAD10",
                    "available": "All Microcontrollers",
                    "description": "word_variable = ReadAD10( ANX )",
                    "funcdesc": "ReadAD10 is a function that can be used to read the built-in analog to digital converter that many microcontroller chips include.  The port should be specified as AN0, AN1, AN2, etc. or ANA0, ANA1, ANA2, etc., up to the number of analog inputs available on the chip that is in use.  Those familiar with Atmel AVR microcontrollers can also refer to the ports as ADC0, ADC1, etc.  Refer to the datasheet for the microcontroller chip to find the number of ports available.  (Note: its perfectly acceptable to use ANx on AVR, or ADCx on the microcontroller.)"
                },
                {
                    "name": "ReadAD12",
                    "available": "All Microcontrollers",
                    "description": "user_variable = ReadAD12( ANX )",
                    "funcdesc": "ReadAD12 is a function that can be used to read the built-in analog to digital converter that many microcontroller chips include.  Port should be specified as AN0, AN1, AN2, etc. or ANA0, ANA1, ANA2, etc., up to the number of analog inputs available on the chip that is in use.  Those familiar with Atmel AVR microcontrollers can also refer to the ports as ADC0, ADC1, etc.  Refer to the datasheet for the microcontroller chip to find the number of ports available.  (Note: its perfectly acceptable to use ANx on AVR, or ADCx on the microcontroller.)"
                },
                {
                    "name": "FnLSL",
                    "available": "All Microcontrollers",
                    "description": "BitsOut = FnLSL(BitsIn, NumBits)",
                    "funcdesc": "FnLSL (Logical Shift Left) will perform a Bitwise left shift. FnLSL will return BitsIn shifted NumBits to the left, it is equivalent to the 'C' operation:\n\nBitsOut = BitsIn << NumBits"
                },
                {
                    "name": "FnLSR",
                    "available": "All Microcontrollers",
                    "description": "BitsOut = FnLSR(BitsIn, NumBits)",
                    "funcdesc": "FnLSR (Logical Shift Right) will perform a Bitwise right shift. FnLSR will return BitsIn shifted NumBits to the right, it is equivalent to the 'C' operation:\n\nBitsOut = BitsIn >> NumBits"
                },
                {
                    "name": "SetWith",
                    "available": "All Microcontrollers",
                    "description": "SetWith(TargetBit, Source)",
                    "funcdesc": "SetWith is an extended version of SET, it allows a Bit Field to be set or cleared by evaluating the content of Source. SetWith should always be used when TargetBit is an I/O Bit and Source is a Function, in order to avoid the possibility of I/O jitter.\nSource may be a variable and of type: Bit, Byte, Word or Long, a Constant, an expression or a Function.\nIt will SET TargetBit to 1 if Source evaluates to anything other than zero. TargetBit will always be a 1 or a 0 regardless of the variable type of TargetBit."
                },
                {
                    "name": "EPRead",
                    "available": "Microchip PIC|Atmel AVR",
                    "description": "EPRead location, store",
                    "funcdesc": "EPRead is used to read information from the EEPROM data storage that many microcontroller chips are equipped with. location represents the location to read data from, and varies from one chip to another. store is the variable in which to store the data after it has been read from EEPROM."
                },
                {
                    "name": "EPWrite",
                    "available": "Microchip PIC|Atmel AVR",
                    "description": "EPWrite location, data",
                    "funcdesc": "EPWrite is used to write information to the EEPROM data storage, so that it can be accessed later by a programmer on the PC, or by the EPRead command. location represents the location to read data from, and varies from one chip to another. data is the data that is to be written to the EEPROM, and can be a value or a variable."
                },
                {
                    "name": "HEFRead",
                    "available": "Microchip PIC",
                    "description": "HEFRead ( location, data )",
                    "funcdesc": "HEFRead is used to read information, byte values, from HEFM, so that it can be accessed for use in a user program.\nlocation represents the location or relative address to read. The location will range from location 0 to HEF_BYTES - 1, or for all practical purposes 0-127 since all PIC Microcontrollers with HEF support 128 bytes of HEF Memory. HEF_BYTES is a Great Cow BASIC constant that represents the number of bytes of HEF Memory.\ndata is the data that is to be read from the HEFM data storage area.\nThis can be a byte value or a byte variable.\nThis method reads data from HEFM given the specific relative location.\nThis method is similar to the EPRead method for EEPROM."
                },
                {
                    "name": "HEFReadWord",
                    "available": "Microchip PIC",
                    "description": "HEFReadWord ( location, data_word_variable )",
                    "funcdesc": "HEFReadWord is used to read information, word values, from HEFM so that it can be accessed for use in a user program.\nlocation represents the location or relative address to read. The location will range from location 0 to HEF_BYTES - 1, or for all practical purposes 0-127 since all PIC Microcontrollers with HEF support 128 bytes of HEF Memory. HEF_BYTES is a Great Cow BASIC constant that represents the number of bytes of HEF Memory.\ndata is the data that is to be read from the HEFM data storage.\nThis must be a word variable.\nThis method reads data from HEFM given the specific relative location."
                },
                {
                    "name": "HEFWrite",
                    "available": "Microchip PIC",
                    "description": "HEFWrite ( location, data )",
                    "funcdesc": "HEFWrite is used to write information, byte values, to HEFM so that it can be accessed later for use in a user program.\nlocation represents the location or relative address to write. The location will range from location 0 to HEF_BYTES - 1, or for all practical purposes 0-127 since all PIC Microcontrollers with HEF support 128 bytes of HEF Memory. HEF_BYTES is a Great Cow BASIC constant that represents the number of bytes of HEF Memory.\ndata is the data that is to be written to the HEFM location.\nThis can be a byte value or a byte variable.\nThis method writes information to the HEFM given the specific location. This method is similar to the EPWrite method for EEPROM."
                },
                {
                    "name": "HEFWriteWord",
                    "available": "Microchip PIC",
                    "description": "HEFWriteWord ( location, data_word_value )",
                    "funcdesc": "HEFWriteWord is used to write information, word values, to HEFM, so that it can be accessed in a user program via the HEFReadWord command.\nlocation presents the location or relative address to write write. A data Word requires 2 HEF Locations, therefore the location will range from 0 to 126 in steps of 2.\ndata is the data that is to be written to the HEFM location.This can be a word value or a word variable.\nThis method writes information to the HEFM given the specific location in the HEFM data storage . This method is similar to the methods for EEPROM but this method supports Word values."
                },
                {
                    "name": "HEFReadBlock",
                    "available": "Microchip PIC",
                    "description": "HEFReadBlock ( block_number,  buffer(), [, num_bytes] )",
                    "funcdesc": "HEFReadBlock is used to read information from the HEFM data storage into the buffer.Once the buffer is populated it can be accessed for use within a user program.\n\nThe parameters are as follows:\n\nblock_number represents the block to be written to.The block_number parameter is used to calculate the physical memory location(s) that are updated.\nbuffer() represents an array or string.The buffer will be used as the data target for the block read operation.The buffer is handled as a buffer of bytes values.In most cases the buffer should be the same size as a row/block of HEFM.For most PIC Microcontrollers this will be 32 bytes.For PIC microcontrollers with 2KW or less of Flash Program Memory this will be 16 Bytes.Once data is read into the buffer from HEFM, the user program must handle the data as Byte, Word or String values, as appropriate.\nnum_bytes is an optional parameter, and can be used to specify number of bytes to read from HEFM, starting at the first location in the selected HEFM block.This parameter is not normally required as the default is set to the Great Cow BASIC constant HEF_ROWSIZE_BYTES."
                },
                {
                    "name": "HEFWriteBlock",
                    "available": "Microchip PIC",
                    "description": "HEFWriteBlock ( block_number,  buffer(), [, num_bytes] )",
                    "funcdesc": "HEFWriteBlock is used to write information from a user buffer to HEFM. Once the block is written it can be accessed for use within a user program.\n\nThe parameters are as follows:\n\nblock_number represents the block to be written to.The block_number parameter is used to calculate the physical memory location(s) that are updated.\nbuffer() represents an array or string. The buffer will be used as the data source that is written to the HEFM block. The buffer is handled as a buffer of bytes values. In most cases the buffer should be the same size as a row/block of HEFM. For most PIC Microcontrollers this will be 32 bytes. For PIC microcontrollers with 2KW or less of Flash Program Memory this will be 16 Bytes. Best practice is to size the buffer using the HEF_ROWSIZE_BYTES constant. If the size of the buffer exceeds the device specific HEF_ROWSIZE_BYTES, the excess data will not be handled and the buffer will be truncated at the HEF_ROWSIZE_BYTES limit.\nnum_bytes is an optional parameter, and can be used to specify number of bytes to write to HEFM, starting at the first location in the selected HEFM block. This parameter is not normally required as the default is set to the Great Cow BASIC constant HEF_ROWSIZE_BYTES."
                },
                {
                    "name": "HEFEraseBlock",
                    "available": "Microchip PIC",
                    "description": "HEFEraseBlock ( block_number )",
                    "funcdesc": "HEFEraseBlock is used to erase all data locations within the HEFM block. HEFM data within the HEFM block to the erase state value of the device. This Value is 0xFF and will read 0x3FFF if the entire 14bit program memory word is displayed. Use Caution. Once the HEFM block is erased, the HEFM data is gone forever and cannot be recovered unless it was previpusly saved.\n\nThe single parameter is as follows:\n\nblock_number represents the block to be erased.The block_number parameter is used to calculate the physical memory location(s) that are updated."
                },
                {
                    "name": "PFMRead",
                    "available": "Microchip PIC",
                    "description": "PFMRead (location, store)",
                    "funcdesc": "PFMRead reads information from the program memory on chips that support this feature. location is a word variable, and store can be a byte of word.\nThe largest value possible for location depends on the amount of program memory on the Microchip PIC microcontroller.\nThis is an advanced command which should only be used by advanced developers."
                },
                {
                    "name": "PFMWrite",
                    "available": "Microchip PIC",
                    "description": "PFMWrite (location, value)",
                    "funcdesc": "PFMWrite writes information to the program memory on chips that support this feature. location is a word variable, and store can be a byte of word.\nThe largest value possible for location depends on the amount of program memory on the microcontroller.\nThis is an advanced command which should only be used by advanced developers."
                },
                {
                    "name": "ProgramErase",
                    "available": "Microchip PIC",
                    "description": "ProgramErase (location)",
                    "funcdesc": "ProgramErase erases information from the program memory on chips that support this feature. The largest value possible for location depends on the amount of program memory on the Microchip PIC microcontroller, which is given on the datasheet.\nThis command must be called before writing to a block of memory. It is slow in comparison to other Great Cow BASIC commands. Note that it erases memory in 32-byte blocks - see the relevant Microchip PIC microcontroller datasheet for more information.\nThis is an advanced command which should only be used by advanced developers. Care must be taken with this command, as it can easily erase the program that is running on the microcontroller."
                },
                {
                    "name": "ProgramRead",
                    "available": "Microchip PIC",
                    "description": "ProgramRead (location, store)",
                    "funcdesc": "ProgramRead reads information from the program memory on chips that support this feature. location and store are both word variables, meaning that they can store values over 255.\nThe largest value possible for location depends on the amount of program memory on the Microchip PIC microcontroller, which is given on the datasheet. store is 14 bits wide, and thus can store values up to 16383.\nThis is an advanced command which should only be used by advanced developers."
                },
                {
                    "name": "ProgramWrite",
                    "available": "Microchip PIC",
                    "description": "ProgramWrite (location, value)",
                    "funcdesc": "ProgramWrite writes information to the program memory on chips that support this feature. location and value are both word variables.\nThe largest value possible for location depends on the amount of program memory on the microcontroller , which is given on the datasheet. value is 14 bits wide, and thus can store values up to 16383.\nThis is an advanced command which should only be used by advanced developers. ProgramErase must be used to clear a block of memory BEFORE ProgramWrite is called."
                },
                {
                    "name": "SAFRead",
                    "available": "Microchip PIC",
                    "description": "SAFRead ( location, data )",
                    "funcdesc": "SAFRead is used to read information, byte values, from SAFM, so that it can be accessed for use in a user program.\nlocation represents the location or relative address to read. The location will range from location 0 to SAF_BYTES - 1. This cab be from 0-127 or 0-255m depending upon the specific device. HEF_BYTES is a Great Cow BASIC constant that represents the number of bytes of SAF Memory.\ndata is the data that is to be read from the SAFM data storage area. This can be a byte value or a byte variable.\nThis method reads data from SAFM given the specific relative location.\nThis method is similar to the EPRead method for EEPROM."
                },
                {
                    "name": "SAFReadWord",
                    "available": "Microchip PIC",
                    "description": "SAFReadWord ( location, data_word_variable )",
                    "funcdesc": "SAFReadWord is used to read information, word values, from SAFM so that it can be accessed for use in a user program.\nlocation represents the location or relative address to read. The location will range from 0 to SAF_BYTES -1.  Each data Word requires 2 SAF\nLocations, therefore the location will range from either 0 to 254 or 0 to 126 (in steps of 2), depending upon the device.\ndata is the word data that is to be read from the SAFM location. This must be a word variable.\nThis method reads word information from SAFM given the relative location in SAFM."
                },
                {
                    "name": "SAFWrite",
                    "available": "Microchip PIC",
                    "description": "SAFWrite ( location, data )",
                    "funcdesc": "SAFWrite is used to write information, byte values, to SAFM so that it can be accessed later for use in a user program.\nlocation represents the location or relative address to write.\nThe location will range from location 0 to SAF_BYTES - 1, or for all practical purposes 0-255 since all PIC Microcontrollers with SAFM support 256 bytes of SAF Memory.\nHEF_BYTES is a Great Cow BASIC constant that represents the number of bytes of SAF Memory.\ndata is the data that is to be written to the SAFM location. This can be a byte value or a byte variable.\nThis method writes information to SAFM given the specific location. This method is similar to the EPWrite method for EEPROM."
                },
                {
                    "name": "SAFWriteWord",
                    "available": "Microchip PIC",
                    "description": "SAFWriteWord ( location, data_word_value )",
                    "funcdesc": "SAFWriteWord is used to write information, word values, to the SAFM data storage, so that it can be accessed later by a programmer on a Personal, or by the SAFRead commands.\n\nlocation presents the location or relative address to write. The location will range from 0 to SAF_BYTES -1.\nEach data Word requires 2 SAF Locations, therefore the location will range from either 0 to 254 or 0 to 126 (in steps of 2), depending upon the device.\n\ndata is the data that is to be written to the SAFM location. This can be a word value or a word variable.\n\nThis method writes information to SAFM given the specific location in SAFM.\nThis method is similar to the methods for EEPROM, but supports Word values."
                },
                {
                    "name": "SAFReadBlock",
                    "available": "Microchip PIC",
                    "description": "SAFReadBlock ( block_number,  buffer(), [,  num_bytes] )",
                    "funcdesc": "HEFReadBlock is used to read information from the HEFM data storage into the buffer. Once the buffer is populated it can be accessed for use within a user program.\n\nThe parameters are as follows:\n\nblock_number represents the block to be written to. The block_number parameter is used to calculate the physical memory location(s) that are updated.\n\nbuffer() represents an array or string. The buffer will be used as the data target for the block read operation. The buffer is handled as a buffer of bytes values. In most cases the buffer should be the same size as a row/block of SAFM. For most PIC Microcontrollers with SAFM this will be 32 bytes.\n\nnum_bytes is an optional parameter, and can be used to specify number of bytes to read from SAFM, starting at the first location in the selected SAFM block. This parameter is not normally required as the default is set to the Great Cow BASIC constant SAF_ROWSIZE_BYTES."
                },
                {
                    "name": "SAFWriteBlock",
                    "available": "Microchip PIC",
                    "description": "SAFWriteBlock ( block_number,  buffer(), [, num_bytes] )",
                    "funcdesc": "SAFWriteBlock is used to write information from a user buffer to SAFM. Once the block is written it can be accessed for use within a user program\n\nThe parameters are as follows:\n\nblock_number represents the block to be written to. The block_number parameter is used to calculate the physical memory location(s) that are updated.\n\nbuffer() represents an array or string. The buffer will be used as the data source that is written to the SAFM block. The buffer is handled as a buffer of bytes values. In most cases the buffer should be the same size as a row/block of SAFM. For most PIC Microcontrollers this will be 32 bytes.\nBest practice is to size the buffer using the SAF_ROWSIZE_BYTES constant.\nIf the size of the buffer exceeds the device specific SAF_ROWSIZE_BYTES, the excess data will not be handled and the buffer will be truncated at the SAF_ROWSIZE_BYTES limit.\n\nnum_bytes is an optional parameter, and can be used to specify the number of bytes to write to HEFM, starting at the first location in the selected HEFM block. This parameter is not normally required as the default is set to the Great Cow BASIC constant HEF_ROWSIZE_BYTES."
                },
                {
                    "name": "SAFEraseBlock",
                    "available": "Microchip PIC",
                    "description": "SAFEraseBlock ( block_number )",
                    "funcdesc": "SAFEraseBlock is used to erase all data locations within the SAFM block.\nHEFM data within the HEFM block to the erase state value of the device.\nThis Value is 0xFF for each location and will read 0xFFFF if the program memory word is displayed. Use Caution. Once the SAFM block is erased, the SAFEM data is gone forever and cannot be recovered unless it was previpusly saved.\n\nThe single parameter is as follows:\n\nblock_number represents the block to be erased. The block_number parameter is used to calculate the physical memory location(s) that are updated."
                },
                {
                    "name": "SRAMRead",
                    "available": "Microchip PIC|Atmel AVR",
                    "description": "SRAMRead location, store",
                    "funcdesc": "SRAMRead is the method, a function or a subroutine, used to read information from the SRAM data storage.\n\nlocation represents the location to read data from.\n\nstore is the variable in which to store the data after it has been read from SRAM."
                },
                {
                    "name": "SRAMWrite",
                    "available": "Microchip PIC|Atmel AVR",
                    "description": "SRAMWrite location, data",
                    "funcdesc": "SRAMWrite is the method used to write information to the SRAM data storage, so that it can be accessed by the SRAMRead command.\n\nlocation represents the location to read data from, and this location will vary from one application/solution to another.\n\ndata is the data that is to be written to the SRAM, a byte value or a byte variable."
                },
                {
                    "name": "Do",
                    "available": "All Microcontrollers",
                    "description": "Do [{While | Until} condition]",
                    "funcdesc": "The Do command will cause the code between the Do and the Loop to run repeatedly while condition is true or until condition is true, depending on whether While or Until has been specified.\n\nNote that the While or Until and the condition can only be specified once, or not at all. If they are not specified, then the code will repeat endlessly.\n\nOptionally, you can specify a condition to EXIT the Do-Loop immediately."
                },
                {
                    "name": "Loop",
                    "available": "All Microcontrollers",
                    "description": "Loop",
                    "funcdesc": "Finish the current do loop"
                },
                {
                    "name": "End",
                    "available": "All Microcontrollers",
                    "description": "End",
                    "funcdesc": "When the End command is used, the program will immediately stop running.\nThere are very few cases where this command is needed - generally, the program should be an endless loop."
                },
                {
                    "name": "Exit",
                    "available": "All Microcontrollers",
                    "description": "Exit Sub | Exit Function | Exit Do | Exit For | Exit Repeat",
                    "funcdesc": "This command will make the program exit the routine it is currently in, as it would if it came to the end of the routine.\n\nApplies to Subroutines, Functions, For-Next loops, Do-Loop loops and Repeat loops."
                },
                {
                    "name": "For",
                    "available": "All Microcontrollers",
                    "description": "For counter = start To end [Step increment]",
                    "funcdesc": "The For command is ideal for situations where a piece of code needs to be run a set number of times, and where it is necessary to keep track of how many times the code has run. When the For command is first executed, counter is set to start. Then, each successive time the program loops, increment is added to counter, until counter is equal to end. Then, the program continues beyond the Next.\n\nStep and increment are optionals. If Step is not specified, Great Cow BASIC will increment counter by 1 each time the code is run.\n\nincrement can be a positive or negative constant or an integer.\n\nThe Exit For is optional and can be used to exit the loop upon a specific condition."
                },
                {
                    "name": "Next",
                    "available": "All Microcontrollers",
                    "description": "Next",
                    "funcdesc": "Finish the current For"
                },
                {
                    "name": "Gosub",
                    "available": "All Microcontrollers",
                    "description": "Gosub label",
                    "funcdesc": "The GoSub command is used to jump to a label as a subroutine, in a similar way to Goto. The difference is that Return can then be used to return to the line of code after the Goto."
                },
                {
                    "name": "Goto",
                    "available": "All Microcontrollers",
                    "description": "Goto label",
                    "funcdesc": "The Goto command will make the microcontroller jump to the line specified, and continue running the program from there. The Goto command is mainly useful for exiting out of loops - if you need to create an infinite loop, use the Do command instead.\n\nBe careful how you use Goto. If used too much, it can make programs very hard to read.\n\nTo define a label, put the name of the label alone on a line, with just a colon (:) after it."
                },
                {
                    "name": "If",
                    "available": "All Microcontrollers",
                    "description": "If condition Then command",
                    "funcdesc": "The If command is the most common command used to make decisions. If condition is true, then command (short) or program code (long) will be run. If it is false, then the microcontroller will skip to the code located on the next line (short) or after the End If (long form).\n\nIf Else is used, then the condition between If and Else will run if the condition is true, and the code between Else and End If will run if the condition is false.\n\nIf Else if is used, then the condition after the Else if will run if the condition is true."
                },
                {
                    "name": "Else",
                    "available": "All Microcontrollers",
                    "description": "Else",
                    "funcdesc": "The If command is the most common command used to make decisions. If condition is true, then command (short) or program code (long) will be run. If it is false, then the microcontroller will skip to the code located on the next line (short) or after the End If (long form).\n\nIf Else is used, then the condition between If and Else will run if the condition is true, and the code between Else and End If will run if the condition is false.\n\nIf Else if is used, then the condition after the Else if will run if the condition is true."
                },
                {
                    "name": "Then",
                    "available": "All Microcontrollers",
                    "description": "If condition Then command",
                    "funcdesc": "The If command is the most common command used to make decisions. If condition is true, then command (short) or program code (long) will be run. If it is false, then the microcontroller will skip to the code located on the next line (short) or after the End If (long form).\n\nIf Else is used, then the condition between If and Else will run if the condition is true, and the code between Else and End If will run if the condition is false.\n\nIf Else if is used, then the condition after the Else if will run if the condition is true."
                },
                {
                    "name": "IndCall",
                    "available": "All Microcontrollers",
                    "description": "IndCall Address",
                    "funcdesc": "IndCall provides a basic implementation of function pointers. Address is the program memory location of the subroutine that is to be called. There are two ways to specify this - either by providing a direct reference to the subroutine using the @ operator, or by specifying a word variable that contains the address.\n\nThis command is useful for callbacks. For example, a particular subroutine might read bytes from a serial connection, but different actions may need to be taken at different times. A different subroutine could be created for each action, and then the subroutine for the appropriate action could be passed to the serial connection reading routine each time it is called."
                },
                {
                    "name": "Pause",
                    "available": "All Microcontrollers",
                    "description": "Pause time_ms",
                    "funcdesc": "The Pause command will cause the program to pause for a specified time in milliseconds. The only unit of time permitted is milliseconds.\n\nPlease use the wait command to use other units of time."
                },
                {
                    "name": "Repeat",
                    "available": "All Microcontrollers",
                    "description": "Repeat times",
                    "funcdesc": "The Repeat command is ideal for situations where a piece of code needs to be run a set number of times. It uses less memory and runs faster than the For command, and should be used wherever it is not necessary to count how many times the code has run.\n\nOptionally, you can specify a condition to Exit the Repeat-Loop immediately.\n\nRepeat has a maximum repeat value of 65535."
                },
                {
                    "name": "Select Case",
                    "available": "All Microcontrollers",
                    "description": "Select Case var",
                    "funcdesc": "The Select Case control structure is used to select and run a particular section of code, based on the value of var. If var equals value1 then code1 will be run. Once code1 has run, the chip will jump to the End Select command and continue running the program. If none of the other conditions are true, then the code under the Case Else section will be run.\n\nCase var TO var is a range of values. If the value is within the range the code section will be executed.\n\nCase Else is optional, and the program will function correctly without it.\n\nIf there is only one line of code after the Case, the code may look neater if the line is placed after the Case. This is shown below in the example, for cases 3, 4 and 5.\n\nIt is important to note that only one section of code will be run when using Select Case.\n\nThere are two examples shown below."
                },
                {
                    "name": "Wait",
                    "available": "All Microcontrollers",
                    "description": "Wait time units",
                    "funcdesc": "The Wait command will cause the program to wait for either a specified amount of time (such as 1 second), or while/until a condition is true."
                },
                {
                    "name": "FVRInitialize",
                    "available": "All Microcontrollers",
                    "description": "FVRInitialize ( FVR_OFF | FVR_1x | FVR_2x | FVR_4x  )",
                    "funcdesc": "The method is a subroutine that sets the state of the FVR.\n\nFVR_Off =  Fixed Voltage Reference is set to OFF\n\nFVR_1x  =  Fixed Voltage Reference is set to 1.024v\n\nFVR_2x  =  Fixed Voltage Reference is set to 2.048v\n\nFVR_4x  =  Fixed Voltage Reference is set to 4.096v"
                },
                {
                    "name": "FVRIsOutputReady",
                    "available": "All Microcontrollers",
                    "description": "user_var = FVRIsOutputReady()",
                    "funcdesc": "The method is a function that returns the state of the FVR.   The returned value can be assigned to a variable to used as function.\n\nThe method returns 0 or 1.   As follows:\n\n0 = Fixed Voltage Reference output is not ready or not enabled\n\n1 = Fixed Voltage Reference output is ready for use"
                },
                {
                    "name": "IntOff",
                    "available": "Microchip PIC|Atmel AVR",
                    "description": "IntOff",
                    "funcdesc": "IntOff is used to disable interrupts on the microcontroller. It should be used at the start of code which is timing-sensitive, and which would not function correctly if paused and restarted.\n\nIt is essential that IntOn is used to turn interrupts on again after the timing-sensitive code has finished running. If not, no interrupts will be handled.\n\nIt is recommended that IntOff be placed before all code that is timing sensitive, in case interrupts are implemented later.\n\nIntOff will be removed from the assembler if no interrupts are used."
                },
                {
                    "name": "IntOn",
                    "available": "Microchip PIC|Atmel AVR",
                    "description": "IntOn",
                    "funcdesc": "IntOn is used to enable interrupts on the microcontroller after IntOff has disabled them. It should be used at the end of code which is timing-sensitive.\n\nIntOn will be removed from the assembler if no interrupts are used."
                },
                {
                    "name": "On Interrupt",
                    "available": "Microchip PIC|Atmel AVR",
                    "description": "On Interrupt event Call handler",
                    "funcdesc": "On Interrupt will add code to call the subroutine handler whenever the interrupt event occurs. When Call is specified, Great Cow BASIC will enable the interrupt, and call the interrupt handler when it occurs. When Ignore is specified, Great Cow BASIC will disable the interrupt handler and prevent it from being called when the event occurs. If the event occurs while the handler is disabled, then the handler will be called as soon as it is re-enabled. The only way to prevent this from happening is to manually clear the flag bit for the interrupt."
                },
                {
                    "name": "Call",
                    "available": "Microchip PIC|Atmel AVR",
                    "description": "On Interrupt event Call handler",
                    "funcdesc": "On Interrupt will add code to call the subroutine handler whenever the interrupt event occurs. When Call is specified, Great Cow BASIC will enable the interrupt, and call the interrupt handler when it occurs. When Ignore is specified, Great Cow BASIC will disable the interrupt handler and prevent it from being called when the event occurs. If the event occurs while the handler is disabled, then the handler will be called as soon as it is re-enabled. The only way to prevent this from happening is to manually clear the flag bit for the interrupt."
                },
                {
                    "name": "Ignore",
                    "available": "Microchip PIC|Atmel AVR",
                    "description": "On Interrupt event Call handler",
                    "funcdesc": "On Interrupt will add code to call the subroutine handler whenever the interrupt event occurs. When Call is specified, Great Cow BASIC will enable the interrupt, and call the interrupt handler when it occurs. When Ignore is specified, Great Cow BASIC will disable the interrupt handler and prevent it from being called when the event occurs. If the event occurs while the handler is disabled, then the handler will be called as soon as it is re-enabled. The only way to prevent this from happening is to manually clear the flag bit for the interrupt."
                },
                {
                    "name": "KeypadData",
                    "available": "All Microcontrollers",
                    "description": "var = KeypadData",
                    "funcdesc": "This function will return a value corresponding to the key that is pressed on the keypad. Note that if two or more keys are pressed, then only one value will be returned."
                },
                {
                    "name": "KeypadRaw",
                    "available": "All Microcontrollers",
                    "description": "largevar = KeypadRaw",
                    "funcdesc": "This function will return a 16 bit value, in which each bit corresponds to a key on the keypad. If the key is pressed its bit will hold 1, and if it is released its bit will contain a 0."
                },
                {
                    "name": "ST7920GLCDClearGraphics",
                    "available": "All Microcontrollers",
                    "description": "ST7920GLCDClearGraphics",
                    "funcdesc": "This command clears the GCLD display."
                },
                {
                    "name": "ST7920GLCDDisableGraphics",
                    "available": "All Microcontrollers",
                    "description": "ST7920GLCDDisableGraphics",
                    "funcdesc": "This command sets the GCLD display controller to text mode."
                },
                {
                    "name": "ST7920GLCDEnableGraphics",
                    "available": "All Microcontrollers",
                    "description": "ST7920GLCDEnableGraphics",
                    "funcdesc": "This command sets the GCLD display controller to text mode."
                },
                {
                    "name": "ST7920GraphicTest",
                    "available": "All Microcontrollers",
                    "description": "ST7920GraphicTest",
                    "funcdesc": "This command tests the graphics functionality of the GLCD display."
                },
                {
                    "name": "ST7920LineHs",
                    "available": "All Microcontrollers",
                    "description": "ST7920LineHs ( Xpos, Ypos, XLength, Style)",
                    "funcdesc": "This command draws a line with a specific style. The style is based on the bits value of the byte passed to the routine."
                },
                {
                    "name": "ST7920Locate",
                    "available": "All Microcontrollers",
                    "description": "ST7920Locate ( Xpos, Ypos)",
                    "funcdesc": "This command locates the pixel at the specific X and Y location of the text screen. Subsequent printing to the GLCD will place a character to the GLCD controller on the specified row and column. Due to the design of the ST7920 controller (to accomodate Mandarin and Cyrillic), you must place the text on the column according to the numbers above the diagram below."
                },
                {
                    "name": "ST7920Tile",
                    "available": "All Microcontrollers",
                    "description": "ST7920Tile ( word variable )",
                    "funcdesc": "This command tiles the screen with the word value provided."
                },
                {
                    "name": "ST7920lineh",
                    "available": "All Microcontrollers",
                    "description": "ST7920lineh ( Xpos, Ypos, xUnitsStyle, )",
                    "funcdesc": "This command draws a horizontal line with the specific style. The style can be ON or OFF. Default is ON.\n\nThis is called by the GLCD common routines."
                },
                {
                    "name": "ST7920linev",
                    "available": "All Microcontrollers",
                    "description": "ST7920linev ( Xpos, Ypos, xUnitsStyle, )",
                    "funcdesc": "This command draws a vertical line with the specific style. The style can be ON or OFF. Default is ON\n\nThis is called by the GLCD common routines."
                },
                {
                    "name": "ST7920GLCDReadByte",
                    "available": "All Microcontrollers",
                    "description": "byte_variable = ST7920GLCDReadByte",
                    "funcdesc": "This function return the word value (16 bits) of the GLCD display for the current XY position.\n\nThis is called by the GLCD common routines.\n\nSee the data sheet for more information."
                },
                {
                    "name": "ST7920GWriteCommand",
                    "available": "All Microcontrollers",
                    "description": "ST7920GWriteCommand ( byte_variable)",
                    "funcdesc": "This command writes a command to the controller.\n\nSee the data sheet for more information."
                },
                {
                    "name": "ST7920GWriteData",
                    "available": "All Microcontrollers",
                    "description": "ST7920GWriteData ( byte_variable)",
                    "funcdesc": "This command writes data to the controller.\n\nSee the data sheet for more information."
                },
                {
                    "name": "ST7920gReaddata",
                    "available": "All Microcontrollers",
                    "description": "byte_variable = ST7920gReaddata",
                    "funcdesc": "This function return the word value (16 bits) of the GLCD display for the current XY position.\n\nSee the data sheet for more information."
                },
                {
                    "name": "Box",
                    "available": "All Microcontrollers",
                    "description": "Box(LineX1,LineY1, LineX2, LineY2 [, LineColour ] )",
                    "funcdesc": "Draws a box on a graphic LCD from the upper corner of pixel position X1, Y1 location to pixel position X2,Y2 location.\n\nLineColour can be specified. Typical the value is 0 or 1 for GLCDForeGround and GLCDBackGround respectively."
                },
                {
                    "name": "Circle",
                    "available": "All Microcontrollers",
                    "description": "Circle(XPixelPosition, YPixelPosition, Radius [ [,Optional LineColour] [,Optional Rounding] ] )",
                    "funcdesc": "Draws a circle on a GLCD at XPixelPosition, YPixelPosition with a specific Radius.\n\nThe constant GLCD_PROTECTOVERRUN can be added to prevent circles from re-drawing at the screen edges. Ensure the GLCD_Width and GLCD_HEIGHT constants are set correctly when using this additional constant."
                },
                {
                    "name": "Ellipse",
                    "available": "All Microcontrollers",
                    "description": "Ellipse(XPixelPosition, YPixelPosition, XRadius, YRadius [,Optional LineColour] )",
                    "funcdesc": "Draws a Ellipse on a GLCD at XPixelPosition, YPixelPosition with a specific vertex of XRadius and YRadius.\nThe constant\nGLCD_PROTECTOVERRUN can be added to prevent Ellipses from re-drawing at the screen edges. Ensure the GLCD_Width and GLCD_HEIGHT constants are set correctly when using this additional constant."
                },
                {
                    "name": "FilledBox",
                    "available": "All Microcontrollers",
                    "description": "FilledBox(LineX1,LineY1, LineX2, LineY2, Optional LineColour = 1)e",
                    "funcdesc": "Draws a filled box on a graphic LCD from the upper corner of pixel X1, Y1 location to pixel X2,Y2 location."
                },
                {
                    "name": "FilledCircle",
                    "available": "All Microcontrollers",
                    "description": "FilledCircle(XPixelPosition, YPixelPosition, Radius [,Optional LineColour] )",
                    "funcdesc": "Draws a circle on a GLCD at XPixelPosition, YPixelPosition with a specific Radius. "
                },
                {
                    "name": "FilledEllipse",
                    "available": "All Microcontrollers",
                    "description": "FilledEllipse(XPixelPosition, YPixelPosition, XRadius, YRadius [,Optional LineColour] )",
                    "funcdesc": "XPixelPosition, YPixelPosition with a specific vertex of XRadius and YRadius.\n\nThe constant GLCD_PROTECTOVERRUN can be added to prevent FilledEllipses from re-drawing at the screen edges. Ensure the GLCD_Width and GLCD_HEIGHT constants are set correctly when using this additional constant."
                },
                {
                    "name": "FilledEllipse",
                    "available": "All Microcontrollers",
                    "description": "FilledEllipse(XPixelPosition, YPixelPosition, XRadius, YRadius [,Optional LineColour] )",
                    "funcdesc": "Draws a FilledEllipse on a GLCD at XPixelPosition, YPixelPosition with a specific vertex of XRadius and YRadius.\n\nThe constant GLCD_PROTECTOVERRUN can be added to prevent FilledEllipses from re-drawing at the screen edges. Ensure the GLCD_Width and GLCD_HEIGHT constants are set correctly when using this additional constant."
                },
                {
                    "name": "FilledTriangle",
                    "available": "All Microcontrollers",
                    "description": "FilledTriangle( XPixelPosition1, YPixelPosition1, XPixelPosition2, YPixelPosition2, XPixelPosition3, YPixelPosition3 [,Optional LineColour] )",
                    "funcdesc": "Draws a FilledTriangle on a GLCD at XPixelPositionN, YPixelPositionN.\n\nThe constant\nGLCD_PROTECTOVERRUN can be added to prevent FilledTriangles from re-drawing at the screen edges. Ensure the GLCD_Width and GLCD_HEIGHT constants are set correctly when using this additional constant."
                },
                {
                    "name": "GLCDCLS",
                    "available": "All Microcontrollers",
                    "description": "GLCDCLS [GLCDBackground]",
                    "funcdesc": "Clears the screen of a Graphic LCD. This command is supported by all GLCD displays.\n\nFor colour GLCD displays only. The optional parameter can be used to clear the screen to a specific colour. Using this additional parameter will also change the GLCDBackground colour to this same colour.\n\nSpecific to the ST7920 GLCD devices. This command supports the clearing the GLCD to either text mode or graphics mode."
                },
                {
                    "name": "GLCDDisplay",
                    "available": "All Microcontrollers",
                    "description": "GLCDDisplay Off | On",
                    "funcdesc": "Places the GLCD in sleep mode or enables the GLCD for normal operations."
                },
                {
                    "name": "GLCDDrawString",
                    "available": "All Microcontrollers",
                    "description": "GLCDDrawString(CharLocX, CharLocY, String [, Optional Colour] )",
                    "funcdesc": "Displays an ASCII character at a specified X and Y location.\nOn a 128x64 Graphic LCD :\nX = 1 to 128\nY = 1 to 64"
                },
                {
                    "name": "GLCDPrint",
                    "available": "All Microcontrollers",
                    "description": "GLCDPrint(PrintLocX, PrintLocY, PrintData_Byte [, Optional Colour] )",
                    "funcdesc": "Prints data values (byte, word, long or string) at a specified location on the GLCD screen."
                },
                {
                    "name": "GLCDPrintLargeFont",
                    "available": "All Microcontrollers",
                    "description": "GLCDPrintLargeFont( PrintLocX, PrintLocY, PrintData_String [, Optional Colour] )",
                    "funcdesc": "Prints data values (byte, word, long or string) at a specified location on the GLCD screen."
                },
                {
                    "name": "GLCDPrintWithSize",
                    "available": "All Microcontrollers",
                    "description": "GLCDPrintWithSize(PrintLocX, PrintLocY, PrintData_Byte , FontSize [, Color ] )",
                    "funcdesc": "Prints data values (byte, word, long or string) at a specified location on the GLCD screen with a specific font size."
                },
                {
                    "name": "GLCDLocateString",
                    "available": "All Microcontrollers",
                    "description": "GLCDLocateString(PrintLocX, PrintLocY )",
                    "funcdesc": "Moves the GLCD string pointer to the specified location on the GLCD screen.\nPrintLocX is the X corrdinate location for the data\nPrintLocY is the Y coordinate location for the data\n\nFor the purpose of this command. The screen addressing is the first line equates to the parameter 1, the second line equates to the paramter 2 etc."
                },
                {
                    "name": "GLCDPrintString",
                    "available": "All Microcontrollers",
                    "description": "GLCDPrintString( String )",
                    "funcdesc": "Prints string character(s) at a current XY location on the GLCD screen.\n\nWhere String is a String or String variable of the data to display\n\nThis command will NOT move the to start of the next line after the string has been displayed"
                },
                {
                    "name": "GLCDPrintStringLn",
                    "available": "All Microcontrollers",
                    "description": "GLCDPrintStringLn( String )",
                    "funcdesc": "Prints string character(s) at a current XY location on the GLCD screen.\n\nWhere String is a String or String variable of the data to display\n\nThis command will move to the start of the next line after the string has been displayed"
                },
                {
                    "name": "GLCDROTATE",
                    "available": "All Microcontrollers",
                    "description": "GLCDROTATE LANDSCOPE | PORTRAIT_REV | LANDSCAPE_REV  | PORTRAIT",
                    "funcdesc": "Rotate the GLCD display to a relative position.\n\nGLCD rotation needs to be supported by the GLCD chipset. NOT all GLCD chipset support these commands."
                },
                {
                    "name": "GLCDReadByte",
                    "available": "All Microcontrollers",
                    "description": "byte_variable = GLCDReadByte",
                    "funcdesc": "Reads a byte of data from the Graphic LCD memory"
                },
                {
                    "name": "GLCDTime",
                    "available": "All Microcontrollers",
                    "description": "GLCDTime",
                    "funcdesc": "This will call the delay routine that delays data transmissions. By default this is set to 20, which equate to 20 us. GLCDTimeDelay default of 20us is for 32Mhz support. The can be reduced for slower chip speeds by change the constant ST7920WriteDelay."
                },
                {
                    "name": "GLCD_Open_PageTransaction",
                    "available": "All Microcontrollers",
                    "description": "GLCD_Open_PageTransaction",
                    "funcdesc": "To make the operation of GLCD seamless - specific library supports GLCDTransaction.   GLCDTransaction automatically manages the methods to update the GLCD display via a RAM memory buffer, where this buffer can be small relative to the size of the total number of GLCD pixels.\n\nThe process of GLCDtransaction sends GLCD commands to the GLCD display on a page and page basis.\nEach page is the size of the buffer and for a large GLCD display the number of pages may be equivilent to the numbers of pixels high (height).\n\nGLCDTransaction simplies the operation by ensure the buffer is setup correctly, handles the GLCD appropiately, handles the sending of the buffer and then close out the update to the display."
                },
                {
                    "name": "GLCD_Close_PageTransaction",
                    "available": "All Microcontrollers",
                    "description": "GLCD_Close_PageTransaction",
                    "funcdesc": "To make the operation of GLCD seamless - specific library supports GLCDTransaction.   GLCDTransaction automatically manages the methods to update the GLCD display via a RAM memory buffer, where this buffer can be small relative to the size of the total number of GLCD pixels.\n\nThe process of GLCDtransaction sends GLCD commands to the GLCD display on a page and page basis.\nEach page is the size of the buffer and for a large GLCD display the number of pages may be equivilent to the numbers of pixels high (height).\n\nGLCDTransaction simplies the operation by ensure the buffer is setup correctly, handles the GLCD appropiately, handles the sending of the buffer and then close out the update to the display."
                },
                {
                    "name": "GLCDWriteByte",
                    "available": "All Microcontrollers",
                    "description": "GLCDWriteByte (LCDByte)",
                    "funcdesc": "Writes a byte of data to the Graphic LCD memory"
                },
                {
                    "name": "Line",
                    "available": "All Microcontrollers",
                    "description": "Line(LineX1,LineY1, LineX2, LineY2, Optional LineColour = 1)",
                    "funcdesc": "Draws a line on a GLCD from pixel X1, Y1 location to pixel X2,Y2 location."
                },
                {
                    "name": "Hyperbole",
                    "available": "All Microcontrollers",
                    "description": "Hyperbole (x,  y,  a_axis,  b_axis,  type, ModeStop, optional LineColour=GLCDForeground)",
                    "funcdesc": "Draws on a GLCD an hyperbole with equation (x/(a)2-(y/(b)2=1, centered at pixel positions (x, y) with axis a and b.\n\nThe hyperbole can be aligned either along the x axis or along the y axis.\n\nBoth cases a_axis>=b:axis and a_axis<b_axis are accepted.\n\nThe hyperbole is an unbounded curve made by four branches\n\nDrawing hyperbole on the screen can be stopped by following two different criteria: - a branch has reached a border of the display - all branches have reached the display border\n\nFor an hyperbole centered on the display these criteria are equivalent"
                },
                {
                    "name": "Parabola",
                    "available": "All Microcontrollers",
                    "description": "Parabola (x,  y,  p_factor,  type, modestop, optional LineColour=GLCDForeground)",
                    "funcdesc": "Draws on a GLCD a parabola with equation y^2=2*p_factor*x, centered at pixel positions (x, y) .\n\nThe parabola is an unbounded curve.\n\nThe parabola can be alined either along the x axis or along the y axis.\n\nDrawing parabola on the screen can be constrained by following two different criteria: - a branch has reached a border of the display. - both branches have reached the display border."
                },
                {
                    "name": "PSet",
                    "available": "All Microcontrollers",
                    "description": "PSet(XPosition, YPosition, GLCDState)",
                    "funcdesc": "Sets or Clears a Pixel at the specified XPosition, YPosition. Use GLCDState set to 1 to set the pixel and a 0 clears the pixel."
                },
                {
                    "name": "Triangle",
                    "available": "All Microcontrollers",
                    "description": "Triangle(XPixelPosition1, YPixelPosition1, XPixelPosition2, YPixelPosition2, XPixelPosition3, YPixelPosition3 [,Optional LineColour] )",
                    "funcdesc": "Draws a Triangle on a GLCD at XPixelPositionN, YPixelPositionN.\nThe constant\nGLCD_PROTECTOVERRUN can be added to prevent Triangles from re-drawing at the screen edges. Ensure the GLCD_Width and GLCD_HEIGHT constants are set correctly when using this additional constant."
                },
                {
                    "name": "ADS7843_Init",
                    "available": "All Microcontrollers",
                    "description": "ADS7843_Init",
                    "funcdesc": "The ADS7843 device is a 12-bit sampling Analog-to-Digital Converter (ADC) with a synchronous serial interface and low on resistance switches for driving touch screens.\n\nThe Great Cow Basic driver is integrated with the SDD1289 GLCD driver. To use the ADS7843 driver the following is required to added to the Great Cow BASIC source file.\n\nADS7843_Init is required to initialise the touch screen. This is mandated.\n\nADS7843_GetXY this sub-routine returns the X and Y coordinates of touched point.\n\nADS7843_SetPrecision this sub-routine sets the level of precision of the touch screen."
                },
                {
                    "name": "CLS",
                    "available": "All Microcontrollers",
                    "description": "CLS",
                    "funcdesc": "The CLS command clears the contents of the LCD, and returns the cursor to the top left corner of the screen"
                },
                {
                    "name": "Get",
                    "available": "All Microcontrollers",
                    "description": "var = Get(Line, Column)",
                    "funcdesc": "The Get function reads the ASCII character code at a given location on the LCD."
                },
                {
                    "name": "LCDBacklight",
                    "available": "All Microcontrollers",
                    "description": "LCDBacklight ( On | Off )",
                    "funcdesc": "Sets the LCD backlight on or off\n\nDo not connect the LCD backlight directly to the microcontroller! Always refer to the datasheet for the correct method to drive the LCD backlight.\n\nFor 0, 4, 8, 404 LCD types you must define the controlling port.pin for the LCD backlight."
                },
                {
                    "name": "LCDCreateChar",
                    "available": "All Microcontrollers",
                    "description": "LCDCreateChar char, chardata()",
                    "funcdesc": "The LCDCreateChar command is used to send a custom character to the LCD.\n\nEach character on the LCD is made up from an 8 row by 5 column (5x8) matrix of pixels. The data to be sent to the LCD is composed of an 8 element array, where each element corresponds to a row. Inside each element, the 5 lowest bits make up the data for the corresponding row. When a bit is set a dot will be drawn at the matching location; when it is cleared, no dot will appear.\n\nAn array of more than 8 elements may be used, but only the first 8 will be read.\n\nchar is the ASCII value of the character to create. ASCII codes 0 through 7 are usually used to store custom characters.\nchardata() is an array containing the data for the character."
                },
                {
                    "name": "LCDCreateGraph",
                    "available": "All Microcontrollers",
                    "description": "LCDCreateGraph value",
                    "funcdesc": "The LCDCreateGraph command will create a graph like character which can then be displayed on the LCD"
                },
                {
                    "name": "LCDCMD",
                    "available": "All Microcontrollers",
                    "description": "LCDCMD value",
                    "funcdesc": "This command set LCD specific instructions to the LCD display."
                },
                {
                    "name": "LCDCursor",
                    "available": "All Microcontrollers",
                    "description": "LCDCursor value",
                    "funcdesc": "The LCDCursor command will accept the following parameters:\n\nLCDON, LCDOFF, CURSORON, CURSOROFF, FLASHON, FLASHOFF\n\nFLASH, and ON/OFF have been retained for backward compatibility with older releases of GCB.\n\nLCDON will turn on (restore) the LCD display.\nLCDOFF will turn off (hide) the LCD display.\nCURSORON will turn on the cursor.\nCURSOROFF will turn off the cursor.\nFLASHON will flash the cursor.\nFLASHOFF will stop flashing the cursor"
                },
                {
                    "name": "LCDHex",
                    "available": "All Microcontrollers",
                    "description": "LCDHex value",
                    "funcdesc": "The LCDHex will display the byte value as a 1 or 2 character HEX string.\n\nvalue is a byte value from 0 to 255.\n\nLeadingZeroActive is a constant or byte value of 2."
                },
                {
                    "name": "LCDHome",
                    "available": "All Microcontrollers",
                    "description": "LCDHome",
                    "funcdesc": "The LCDHome command will return the cursor to home position.\n\nThe currentcontents of the LCD screen will be retained."
                },
                {
                    "name": "LCDDisplayOn",
                    "available": "All Microcontrollers",
                    "description": "LCDDisplayOn",
                    "funcdesc": "Will turn on (restore) the LCD display"
                },
                {
                    "name": "LCDDisplayOff",
                    "available": "All Microcontrollers",
                    "description": "LCDDisplayOff",
                    "funcdesc": "Will turn off (hide) the LCD display."
                },
                {
                    "name": "LCDSpace",
                    "available": "All Microcontrollers",
                    "description": "LCDSpace value",
                    "funcdesc": "The LCDSpace command will print the required number of spaces on the LCD display\n\nvalue is a byte value from 1 to 255. Where the value is the number of spaces required."
                },
                {
                    "name": "LCDWriteChar",
                    "available": "All Microcontrollers",
                    "description": "LCDWriteChar char",
                    "funcdesc": "The LCDWriteChar command will show the specified character on the LCD, at the current cursor position.\n\nchar is the ASCII value of the character to show. On most LCDs, characters 0 through 7 are user defined, and can be set using the LCDCreateChar command."
                },
                {
                    "name": "Locate",
                    "available": "All Microcontrollers",
                    "description": "Locate Line, Column",
                    "funcdesc": "The Locate command is used to move the cursor on the LCD to the given location.\n\nLine is line number on the LCD display. A byte value from 0 to 255.\n\nColumn is column number on the LCD display. A byte value from 0 to 255."
                },
                {
                    "name": "Print",
                    "available": "All Microcontrollers",
                    "description": "Print string",
                    "funcdesc": "The Print command will show the contents of a variable on the LCD. It can display string, word, byte, long or integer variables."
                },
                {
                    "name": "Put",
                    "available": "All Microcontrollers",
                    "description": "Put Line, Column, Character",
                    "funcdesc": "The Put command writes the given ASCII character code to the current location on the LCD.\n\nLine is line number on the LCD display. A byte value from 0 to 255.\n\nColumn is column number on the LCD display. A byte value from 0 to 255.\n\nCharacter is the requried ASCII code. A byte value from 0 to 255."
                },
                {
                    "name": "PWMOut",
                    "available": "All Microcontrollers",
                    "description": "PWMOut channel, duty cycle, cycles",
                    "funcdesc": "channel sets the channel that the PWM is to be generated on. This must have been defined previously by setting the constants PWM_Out1\n\nPWM_Out2, PWM_Out3 or PWM_Out4. The maximum number of channels available is 4.\n\nduty cycle specifies the PWM duty cycle, and ranges from 0 to 255. 255 corresponds to 100%, 127 to 50%, 63 to 25%, and so on.\n\ncycles is used to set the amount of PWM pulses to supply. This is useful for situations in which a pulse of a specific length is required."
                },
                {
                    "name": "HPWMUpdate",
                    "available": "Microchip PIC",
                    "description": "HPWMUpdate ( channel, duty_cycle )",
                    "funcdesc": "This command only supports the previously called HPWM 10 Bit command, or, if you have set more than one HPWM 10 Bit PWM channel then to use the command you must have set the channel to the same frequency.\n\nThe command only supports the hardware PWM module of the Microchip PIC microcontroller to generate a PWM waveform at the previously defined frequency and timer source.\n\nchannel is 1, 2, 3, 4, 5, 6, 7 or 8. These corresponds to the HPWM1 through to HPWM8 respectively. The channel MUST be supported by the microcontroller. Check the microcontroller specific datasheet for the available channel.\n\nduty cycle specifies the desired duty cycle of the PWM signal, and ranges from 0 to 1023 where 1023 is 100% duty cycle."
                },
                {
                    "name": "HPWMOff",
                    "available": "All Microcontrollers",
                    "description": "HPWMOff ( channel, PWMHardware )",
                    "funcdesc": "This command will disable the output of the PWM module on the Microchip PIC chip.\n\nPWMHardware is a Great Cow BASIC defined constant not a user vaariable."
                },
                {
                    "name": "HPWM16",
                    "available": "All Microcontrollers",
                    "description": "HPWM16 channel, frequency, duty cycle",
                    "funcdesc": "This command sets up the hardware PWM module of the Microchip PIC microcontroller to generate a PWM waveform of the given frequency and duty cycle. Once this command is called, the PWM will be emitted until HPWM16Off method is called.\n\nchannel is 1, 2, 3.. 12. These corresponds to the 16-bit PWM channel respectively.\nThe 16-bit PWM channel MUST be supported by the microcontroller. Check the microcontroller specific datasheet for the available channel.\n\nfrequency sets the frequency of the PWM output. It is measured in KHz. The maximum value allowed is 0xFFFF. The minimum value varies depending on the clock speed. 1 KHz is the minimum on chips 16 MHz or under and 2 Khz is the lowest possible on 20 MHz chips. In situations that do not require a specific PWM frequency, the PWM frequency should equal approximately 1 five-hundredth the clock speed of the microcontroller (ie 40 Khz on a 20 MHz chip, 16 KHz on an 8 MHz chip). This gives the best duty cycle resolution possible.\n\nduty cycle specifies the desired duty cycle of the PWM signal, and ranges from 0 to 0xFFFF where 0xFFFF is 100% duty cycle. This should be a WORD value."
                },
                {
                    "name": "PWMOn",
                    "available": "All Microcontrollers",
                    "description": "PWMOn",
                    "funcdesc": "Only available on Microchip PIC microcontrollers with Capture/Compare/PWM module CCP1.\n\nThis command does not operate on any other CCP channel."
                },
                {
                    "name": "HPWM",
                    "available": "Atmel AVR",
                    "description": "HPWM channel, frequency, duty cycle",
                    "funcdesc": "The HPWM command sets up the hardware PWM module of the Atmel AVR microcontrollers to generate a PWM waveform of the given frequency and duty cycle. Once this command is called, the PWM will be emitted until the duty cycle parameter is written to zero.\n\nIf the need is just one particular frequency and duty cycle, one should use PWMOn and the constants PWM_Freq and PWM_Duty instead. PWMOn for the AVR is uniquely assigned to the OC0B pin, or channel 2. PWMOff will only shutdown the AVR HPWM channel 2.\n\nchannel described as 1, 2, 3,16 correspond to the pins OCR0A, OCR0B.OCR5C as detailed in the channel constant table. Channel 1 and channel 6 are not available.\n\nfrequency sets the frequency of the PWM output measured in Khz. The maximum value allowed is 255 KHz. In situations that do not require a specific PWM frequency, the PWM frequency should equal approximately 4 times the clock speed (GCB chipMHz) of the microcontroller (ie 63 KHz on a 16 MHz chip, 32 KHz on 8 MHz, 4 Khz on 1 MHz). This gives the best duty cycle resolution possible. Alternate frequencies with good duty cycle resolution are 1Khz, and 4Khz with chipMhz values of 16 and 8 respectively.\n\nduty cycle specifies the desired duty cycle of the PWM signal, and ranges from 0 to 255 where 255 is 100% duty cycle. The AVR fast PWM mode has a small spike at the extreme setting of 0x00, on most devices, with each period register rollover. By using the HPWM command, and writing 0x00 to the duty cycle parameter, the PWM signal will shutdown completely and avoid the spike. The PWM signal can then be restarted again with a new HPWM command."
                },
                {
                    "name": "Random",
                    "available": "All Microcontrollers",
                    "description": "var = Random",
                    "funcdesc": "The Random function will generate a pseudo-random number between 0 and 255 inclusive.\n\nThe numbers generated by Random will follow the same sequence every time, until Randomize is used."
                },
                {
                    "name": "Randomize",
                    "available": "All Microcontrollers",
                    "description": "Randomize",
                    "funcdesc": "Randomize is used to seed the pseudo random number generator, so that it will produce a different sequence of numbers each time it is used."
                },
                {
                    "name": "DisplayValue",
                    "available": "All Microcontrollers",
                    "description": "DisplayValue (display, data, dot)",
                    "funcdesc": "This command will display the given value on a seven segment LED display.\n\ndisplay is the number of the display to use. Up to 4 digits.\n\ndata is the value between 0 and F to be shown.\n\ndot is an optional parameter. When it is 1 then the decimal point for that digit is turned on.\n\nThe command also support HEX characters in the range between 0x00 and 0x0F (0 to 15). See example two below for usage."
                },
                {
                    "name": "DisplayChar",
                    "available": "All Microcontrollers",
                    "description": "DisplayChar (display, character, dot)",
                    "funcdesc": "This command will display the given ASCII character on a seven segment LED display.\n\ndisplay is the number of the display to use. Up to 4 digits.\n\ncharacter is the ASCII character to be shown.\n\ndot is an optional parameter. When it is 1 then the decimal point for that digit is turned on.\n\nThis example below is a Common Cathode configuration."
                },
                {
                    "name": "DisplaySegment",
                    "available": "All Microcontrollers",
                    "description": "DisplaySegment (display, data)",
                    "funcdesc": "This command will display the given value on a seven segment LED display.\n\ndisplay is the number of the display to use. Up to 4 digits.\n\ndata is the value between 0 and 255. Where data is the representation of the segments to be set."
                },
                {
                    "name": "TMWrite4Dig",
                    "available": "All Microcontrollers",
                    "description": "TMWrite4Dig (dig1, dig2, dig3, dig4  [, Brightness ],  Colon ]  ] )",
                    "funcdesc": "TM1637 - Command defines each digit (left to right) as 0 to 9 OR 0x00 to 0x0F (15). Additionally 0x10 (16) is a blank, 0x11 (17) is a minus sign, 0x12 (18) is a degree sign, 0x13 (19) is a bracket and 0x14 (20) is a question mark.\n\nBrightness set the brightness (8-15). Colon turns the colon (only on digit 2) to off (0) or on (1)."
                },
                {
                    "name": "TM_Bright",
                    "available": "All Microcontrollers",
                    "description": "TM_Bright = Brightness",
                    "funcdesc": "TM1637 - Brightness sets the brightness for the display with a range of 8 to 15.\nDefault to 15.   "
                },
                {
                    "name": "TMDec",
                    "available": "All Microcontrollers",
                    "description": "TMDec  Value [, Options ]",
                    "funcdesc": "TM1637 - Value is a word value.   Only values from 0 to 9999 can be displayed, values greater than 9999 will be displayed"
                },
                {
                    "name": "TMHex",
                    "available": "All Microcontrollers",
                    "description": "TMHex  Value",
                    "funcdesc": "TM1637 - Value is a word value.   Only values from from 0x0000 to 0xFFFF can be displayed. Non-hex values will be displayed as greater than 9999 will be displayed ??."
                },
                {
                    "name": "TMWriteChar",
                    "available": "All Microcontrollers",
                    "description": "TMWriteChar ( TMaddr, TMchar )",
                    "funcdesc": "TM1637 - TMaddr is 0 , 1 , 2 , 3 (display left to right) TMchar is a letter from A to Z (default alphabet) or from a to z Siekoo alphabet by Alexander Fakoo, more info at: http://en.fakoo.de/siekoo.html. You can insert the special characters (blank, -, ) and/or ?)."
                },
                {
                    "name": "TMWrite6Dig",
                    "available": "All Microcontrollers",
                    "description": "TMWrite6Dig (dig1, dig2, dig3, dig4, dig5, dig6, Brightness,  Point)",
                    "funcdesc": "TM1637 - Command defines each digit (left to right) as 0 to 9 or 0x00 to 0x0F (15). Additionally 0x10 (16) is a blank, 0x11 (17) is a minus sign, 0x12 (18) is a degree sign, 0x13 (19) is a bracket and 0x14 (20) is a question mark.\n\nBrightness set the brightness (8-15). Colon turns the colon (only on digit 2) to off (0) or on (1)."
                },
                {
                    "name": "ReadDigitalTemp",
                    "available": "All Microcontrollers",
                    "description": "ReadDigitalTemp",
                    "funcdesc": "Return the value of the sensor in two global variables. The following two lines must be included in the Great Cow BASIC source file.\n#include <DS18B20.h>\n#define DQ PortC.3 ; change port configuration as required\n\nThis method returns whole part of the sensor value in the byte variable DSint, the method also returns decimal part of the sensor value in the byte variable DSdec."
                },
                {
                    "name": "ReadTemp",
                    "available": "All Microcontrollers",
                    "description": "byte_var = ReadTemp",
                    "funcdesc": "ReadTemp reads the sensor and stores in output variable. The conversion takes up to 750ms. Readtemp carries out a full 12 bit conversion and then rounds the result to the nearest full degree Celsius.\n\nTo read the full 12 bit value of the sensor use the readtemp12 command.\n\nThe temperature is read back in whole degree steps, and the sensor operates from -55 to + 125 degrees Celsius. Note that bit 7 is 0 for positive temperature values and 1 for negative values (ie negative values will appear as 128 + numeric value).\n\nNote the Readtemp command does not work with the older DS1820 or DS18S20 as they have a different internal resolution. This command is not designed to be used with parasitically powered DS18B20 sensors, the 5V pin of the sensor must be connected."
                },
                {
                    "name": "ReadTemp12",
                    "available": "All Microcontrollers",
                    "description": "byte_var = ReadTemp12",
                    "funcdesc": "Reads sensor and stores in output variable. The conversion takes up to 750ms. Readtemp12 carries out a full 12 bit conversion.\n\nThis command is for advanced users only. For standard \n'whole degree\n' data use the Readtemp command.\n\nThe temperature is read back as the raw 12 bit data into a word variable (0.0625 degree resolution). The user must interpret the data through mathematical manipulation. See the DS18B20 datasheet for more information on the 12 bit temperature/data information construct.\n\nThe function readtemp12 does not work with the older DS1820 or DS18S20 as they have a different internal resolution. This command is not designed to be used with parasitically powered DS18B20 sensors, the 5V pin of the sensor must be connected."
                },
                {
                    "name": "DS18B20SetResolution",
                    "available": "All Microcontrollers",
                    "description": "DS18B20SetResolution ( [DS18B20SetResolution_CONTSTANT] )",
                    "funcdesc": "Set the DS18B20 operating resolution.   The configuration register of the DS18B20 allows the user to set the resolution of the temperature-to-digital conversion to 9, 10, 11, or 12 bits.    This method set the operating resolution to either 9, 10, 11, or 12 bits.\n\nCalling the method with no parameter will set the operating resolution of the DS18B20 to 12 bits. See example 3 below."
                },
                {
                    "name": "InitSer",
                    "available": "All Microcontrollers",
                    "description": "InitSer channel, rate, start, data, stop, parity, invert",
                    "funcdesc": "This command will set up the serial communications. The parameters are as follows:\n\nchannel is 1, 2 or 3, and refers to the I/O ports that are used for communication.\n\nrate is the bit rate, which is given by the letter r and then the desiredrate in bps. Acceptable units are r300, r600, r1200, r2400, r4800, r9600 and r19200.\n\nstart gives the number of start bits, which is usually 1. To make the microcontroller wait for the start bit before proceeding with the receive, add 128 to start. (Note: it may be desirable to use the WaitForStart constant here.)\n\ndata tells the program how many data bits are to be sent or received. In most situations t his is 8, but it can range between 1 and 8, inclusive.\n\nstop is the number of stop bits. If start bit 7 is on, then this number will be ignored.\n\nparity refers to a system of error checking used by many devices. It can be odd (in which there must always be an odd number of high bits), even (where the number of high bits must always be even), or none (for systems that do not use parity).\n\ninvert can be either \"normal\" or \"invert\". If it in \"invert\", then high bits will be changed to low, and low to high"
                },
                {
                    "name": "SerSend",
                    "available": "All Microcontrollers",
                    "description": "SerSend channel, data",
                    "funcdesc": "This command will send a byte given by data using the RS232 channel referred to as channel according to the rules set using InitSer."
                },
                {
                    "name": "SerReceive",
                    "available": "All Microcontrollers",
                    "description": "SerReceive channel, output",
                    "funcdesc": "This command will read a byte from the RS232 channel given by channel according to the rules set using InitSer, and store the received byte in the variable output."
                },
                {
                    "name": "SerPrint",
                    "available": "All Microcontrollers",
                    "description": "SerPrint channel, value",
                    "funcdesc": "SerPrint is used to send a value over the serial connection. value can be a string, integer, long, word or byte.\n\nchannel is the serial connection to send data through (1 | 2 |3 ).\n\nSerPrint will not send any new line characters. If the chip is sending to a terminal, these commands should follow SerPrint."
                },
                {
                    "name": "Ser1Send",
                    "available": "All Microcontrollers",
                    "description": "Ser1Send data",
                    "funcdesc": "This command will send a byte given by data using the channel referred to as Ser1.. , Ser2 , Ser3 according to the rules set by the related defines."
                },
                {
                    "name": "Ser2Send",
                    "available": "All Microcontrollers",
                    "description": "Ser2Send data",
                    "funcdesc": "This command will send a byte given by data using the channel referred to as Ser1.. , Ser2 , Ser3 according to the rules set by the related defines."
                },
                {
                    "name": "Ser3Send",
                    "available": "All Microcontrollers",
                    "description": "Ser3Send data",
                    "funcdesc": "This command will send a byte given by data using the channel referred to as Ser1.. , Ser2 , Ser3 according to the rules set by the related defines."
                },
                {
                    "name": "Ser1Print",
                    "available": "All Microcontrollers",
                    "description": "Ser1Print value",
                    "funcdesc": "This command will send a value using the channel referred to as Ser1, Ser2, Ser3. according to the rules set by the related defines. value can be a string, integer, long, word or byte."
                },
                {
                    "name": "Ser2Print",
                    "available": "All Microcontrollers",
                    "description": "Ser1Print value",
                    "funcdesc": "This command will send a value using the channel referred to as Ser1, Ser2, Ser3. according to the rules set by the related defines. value can be a string, integer, long, word or byte."
                },
                {
                    "name": "Ser3Print",
                    "available": "All Microcontrollers",
                    "description": "Ser1Print value",
                    "funcdesc": "This command will send a value using the channel referred to as Ser1, Ser2, Ser3. according to the rules set by the related defines. value can be a string, integer, long, word or byte."
                },
                {
                    "name": "Ser1Receive",
                    "available": "All Microcontrollers",
                    "description": "bytevar = Ser1Receive",
                    "funcdesc": "This function will read a byte using the channel referred to as Ser1.. , Ser2, Ser3. according to the rules set by the related defines. The received byte is stored in the variable bytevar. By default the function waits for the startbit impulse edge before executing the following commands. See the sample files how to realize timeout-functionality or interrupt-driven receiving."
                },
                {
                    "name": "Ser2Receive",
                    "available": "All Microcontrollers",
                    "description": "bytevar = Ser2Receive",
                    "funcdesc": "This function will read a byte using the channel referred to as Ser1.. , Ser2, Ser3. according to the rules set by the related defines. The received byte is stored in the variable bytevar. By default the function waits for the startbit impulse edge before executing the following commands. See the sample files how to realize timeout-functionality or interrupt-driven receiving."
                },
                {
                    "name": "Ser3Receive",
                    "available": "All Microcontrollers",
                    "description": "bytevar = Ser3Receive",
                    "funcdesc": "This function will read a byte using the channel referred to as Ser1.. , Ser2, Ser3. according to the rules set by the related defines. The received byte is stored in the variable bytevar. By default the function waits for the startbit impulse edge before executing the following commands. See the sample files how to realize timeout-functionality or interrupt-driven receiving."
                },
                {
                    "name": "HSerGetNum",
                    "available": "All Microcontrollers",
                    "description": "HSerGetNum myNum",
                    "funcdesc": "This command will read a multi digit number received as ascii chars followed by a CR from an external serial source using a hardware serial module. The command checks that only numbers are input disregarding other characters while waiting for the ending <CR>. It can be used only as a subroutine."
                },
                {
                    "name": "HSerGetString",
                    "available": "All Microcontrollers",
                    "description": "HSerGetString myString",
                    "funcdesc": "This command will read a multi character string received as ascii input to the hardware serial module followed by a CR from an external serial source. It can be used only as a subroutine. Variable type is string and the routine checks for numbers,letters, and puctuation."
                },
                {
                    "name": "HSerPrint",
                    "available": "All Microcontrollers",
                    "description": "HSerPrint user_value",
                    "funcdesc": "HSerPrint is used to send a value over the serial connection. user_value can be a string, integer, long, word or byte. HSerPrint is very similar to Print. The data will be sent out the hardware serial module.\n\nHSerPrint will not send any new line characters. If the chip is sending to a terminal, these commands should follow every HSerPrint :\n\nHSerPrint 13\n\nHSerPrint 10"
                },
                {
                    "name": "HSerPrintStringCRLF",
                    "available": "All Microcontrollers",
                    "description": "DHSerPrintStringCRLF user_string",
                    "funcdesc": "HSerPrintStringCRLF is used to send a string over the serial connection. The parameter can only be a string. HSerPrintStringCRLF is very similar to HserPrint but HserPrint can handle all types of variables.\n\nThe data will be sent out the hardware serial module."
                },
                {
                    "name": "HSerReceive",
                    "available": "All Microcontrollers",
                    "description": "HSerReceive (user_byte_variable)",
                    "funcdesc": "This command will read a byte from the hardware RS232 module. It can be used either as a subroutine or as a function. If used as a subroutine, a variable must be supplied to store the received value in. If used as a function, it will return the received value.\n\nThe subroutine HSerReceive can get a byte from any comport but must set the comport number immediately before the call. If #define USART_BLOCKING is defined then the HserReceive waits in a loop until it receives a byte. If #define USART_BLOCKING is NOT defined then HserReceive returns the new byte that was received OR returns 255 because of DefaultUsartReturnValue = 255 was defined. This is good because it dont hold up your program from executing other commands and your can check it for new data priodically."
                },
                {
                    "name": "HSerReceiveFrom",
                    "available": "All Microcontrollers",
                    "description": "user_byte = HSerReceiveFrom",
                    "funcdesc": "This command will read a byte from the hardware RS232 module. It can be only be used as a function. It will return the received value."
                },
                {
                    "name": "HSerSend",
                    "available": "All Microcontrollers",
                    "description": "HSerSend user_byte",
                    "funcdesc": "This command will send a byte given by user_byte using the hardware RS232 module"
                },
                {
                    "name": "HserPrintByteCRLF",
                    "available": "All Microcontrollers",
                    "description": "HserPrintByteCRLF  user_data",
                    "funcdesc": "This command will send a byte given by user_data using the hardware USART module and then send the ASCII codes 13 and 10. ASCII codes 13 and 10 equate to a carriage return and line feed."
                },
                {
                    "name": "HserPrintCRLF",
                    "available": "All Microcontrollers",
                    "description": "HserPrintCRLF [optional BYTE]",
                    "funcdesc": "This command will send ASCII codes 13 and 10 only using the hardware RS232 module. ASCII codes 13 and 10 equate to a carriage return and line feed.\n\nOptionally, you can add a parameter. The number will determine the number of ASCII codes 13 and 10 set to the hardware RS232 module.\n\nAlso you can choose the comport with second optional parameter if it is not the default comport 1. If there is no first optional parameter then you must have atleast acomma before it to indicate this is the second parameter."
                },
                {
                    "name": "InKey",
                    "available": "All Microcontrollers",
                    "description": "output = InKey",
                    "funcdesc": "The InKey function will read the last pressed key from a PS/2 keyboard, and return an ASCII value corresponding to the key. If no key is pressed, then InKey will return 0.\n\nIt will also monitor Caps Lock, Num Lock and Scroll Lock keys, and update the status LEDs as appropriate."
                },
                {
                    "name": "PS2SetKBLeds",
                    "available": "All Microcontrollers",
                    "description": "PS2SetKBLeds (LedStatus)",
                    "funcdesc": "This routine will turn the status LEDs on a keyboard on or off. LedStatus is a variable, of which the lower 3 bits correspond to the 3 LEDs. Bit 0 is for Scroll Lock, bit 1 controls Num Lock and bit 2 controls Caps Lock.\n\nNote that this routine does not alter the status variables within the INKEY routine - so even if the Caps Lock LED is turned on, Caps Lock will stay off."
                },
                {
                    "name": "PS2ReadByte",
                    "available": "All Microcontrollers",
                    "description": "output = PS2ReadByte",
                    "funcdesc": "PS2ReadByte will read a byte from the PS/2 bus. It will return the byte, or 0 if no data was returned by the PS/2 device.\n\nThe PS/2 bus will normally be held in the inhibit state. PS2ReadByte will uninhibit the bus for 25 ms. If a response is received, it will be read. Then, the bus will be placed back in the inhibit state."
                },
                {
                    "name": "PS2WriteByte",
                    "available": "All Microcontrollers",
                    "description": "PS2WriteByte user_data",
                    "funcdesc": "PS2WriteByte will send a byte to a PS/2 device. Once the byte has been written, the PS/2 bus will be placed in the inhibit state."
                },
                {
                    "name": "I2CAckPollState",
                    "available": "All Microcontrollers",
                    "description": "<test condition> I2CAckPollState",
                    "funcdesc": "Should only be used when I2C routines are operating in Master mode, this command will return the last state of the acknowledge response from a specific I2C device on the I2C bus.\n\nI2CACKPOLL sets the state of variable I2CAckPollState.\nI2CAckPollState can only read - it cannot be set."
                },
                {
                    "name": "I2CAckpoll",
                    "available": "All Microcontrollers",
                    "description": "I2CAckpoll ( I2C_device_address )",
                    "funcdesc": "Should only be used when I2C routines are operating in Master mode, this command will look for a specific I2C device on the I2C bus.\n\nThis sets a global variable I2CAckPollState that can be inspected in your calling routine."
                },
                {
                    "name": "I2CReceive",
                    "available": "All Microcontrollers",
                    "description": "I2CReceive data",
                    "funcdesc": "The I2CReceive command will send data through the I2C connection. If ack is TRUE, or no value is given for ack, then I2CReceive will send an ack.\n\nIf in master mode, I2CReceive will read the data immediately.\n\nIf in slave mode, I2CReceive will wait for the master to send the data before reading. When the method I2CReceive is used in Slave mode the global variable I2CMatch will be set to true when the received value is equal to the constant I2C_ADDRESS."
                },
                {
                    "name": "I2CReset",
                    "available": "All Microcontrollers",
                    "description": "I2CReset",
                    "funcdesc": "This will attempt a reset of the I2C by changing the state of the I2C bus."
                },
                {
                    "name": "I2CRestart",
                    "available": "All Microcontrollers",
                    "description": "I2CRestart",
                    "funcdesc": "If the I2C routines are operating in Master mode, this command will send a start and restart condition in a single command."
                },
                {
                    "name": "I2CSend",
                    "available": "All Microcontrollers",
                    "description": "I2CSend data",
                    "funcdesc": "The I2CSend command will send data through the I2C connection. If ack is TRUE, or no value is given for ack, then I2CSend will wait for an Ack from the receiver before continuing. If in master mode, I2CSend will send the data immediately. If in slave mode, I2CSend will wait for the master to request the data before sending."
                },
                {
                    "name": "I2CStart",
                    "available": "All Microcontrollers",
                    "description": "I2CStart",
                    "funcdesc": "If the I2C routines are operating in Master mode, this command will send a start condition. If routines are in Slave mode, it will pause the program until a start condition is sent by the master. It should be placed at the start of every I2C transmission.\n\nIf interrupt handling is enabled, this command will disable it."
                },
                {
                    "name": "I2CStartoccurred",
                    "available": "All Microcontrollers",
                    "description": "I2CStartoccurred",
                    "funcdesc": "If the I2C routine IS operating in Slave mode, this function will check if a start condition has occurred since the last run of this function. 'Only used in slave mode"
                },
                {
                    "name": "I2CStop",
                    "available": "All Microcontrollers",
                    "description": "I2CStop",
                    "funcdesc": "When in Master mode, this command will send an I2C stop condition, and re-enable interrupts if I2CStart disabled them. In Slave mode, it will re- enable interrupts.\n\nI2CStop should be called at the end of every I2C transmission."
                },
                {
                    "name": "HI2CAckPollState",
                    "available": "All Microcontrollers",
                    "description": "<test condition[s]> HI2CAckPollState",
                    "funcdesc": "Should only be used when I2C routines are operating in Master mode, this command will return the last state of the acknowledge response from a specific I2C device on the I2C bus.\n\nHI2CSend sets the state of variable HI2CAckPollState.\n\nHI2CAckPollState can only read - it cannot be set."
                },
                {
                    "name": "HI2CReceive",
                    "available": "All Microcontrollers",
                    "description": "HI2CReceive data",
                    "funcdesc": "The HI2CReceive command will send data through the I2C connection. If ack is TRUE, or no value is given for ack, then HI2CReceive will send an ack to the I2C bus.\n\nIf in master mode, HI2CReceive will read the data immediately. If in slave mode, HI2CReceive will wait for the master to send the data before reading."
                },
                {
                    "name": "HI2CRestart",
                    "available": "All Microcontrollers",
                    "description": "HI2CRestart",
                    "funcdesc": "If the HI2C routines are operating in Master mode, this command will send a start and restart condition in a single command."
                },
                {
                    "name": "HI2CSend",
                    "available": "All Microcontrollers",
                    "description": "HI2CSend data",
                    "funcdesc": "The HI2CSend command will send data through the I2C connection. If in master mode, HI2CSend will send the data immediately. If in slave mode, HI2CSend will wait for the master to request the data before sending."
                },
                {
                    "name": "HI2CStart",
                    "available": "All Microcontrollers",
                    "description": "HI2CStart",
                    "funcdesc": "If the HI2C routines are operating in Master mode, this command will send a start condition. If routines are in Slave mode, it will pause the program until a start condition is sent by the master. It should be placed at the start of every I2C transmission."
                },
                {
                    "name": "HI2CStartOccurred",
                    "available": "All Microcontrollers",
                    "description": "HI2CStartOccurred",
                    "funcdesc": "Check if a start condition has occurred since the last run of this function\n\nOnly used in slave mode."
                },
                {
                    "name": "HI2CMode",
                    "available": "All Microcontrollers",
                    "description": "HI2CMode Master | Slave",
                    "funcdesc": "Sets the microcontroller to either a Master device or a Slave device.\n\nOnly used in slave mode"
                },
                {
                    "name": "HI2CSetAddress",
                    "available": "All Microcontrollers",
                    "description": "HI2CSetAddress address_number",
                    "funcdesc": "Sets the microcontroller address number in Slave mode.\n\nOnly used in slave mode."
                },
                {
                    "name": "HI2CStop",
                    "available": "All Microcontrollers",
                    "description": "HI2CStop",
                    "funcdesc": "HI2CStop should be called at the end of every I2C transmission."
                },
                {
                    "name": "HI2CStopped",
                    "available": "All Microcontrollers",
                    "description": "HI2CStopped",
                    "funcdesc": "In Slave mode only. Check if start condition received since last used of HI2CStopped."
                },
                {
                    "name": "HI2CWaitMSSP",
                    "available": "All Microcontrollers",
                    "description": "HI2CWaitMSSP",
                    "funcdesc": "The methods sets the global byte variable HI2CWaitMSSPTimeout to 255 ( or True ) if the MSSP module has timeout during operations.\n\nHI2CWaitMSSPTimeout can tested for the status of the I2C bus."
                },
                {
                    "name": "Tone",
                    "available": "All Microcontrollers",
                    "description": "Tone Frequency, Duration",
                    "funcdesc": "This command will produce the specified tone for the specified duration. Frequency is measured in Hz, and Duration is in 10 ms units.\n\nPlease note that this command may not produce the exact frequency specified. While it is accurate enough for error beeps and small pieces of monophonic music, it should not be used for anything that requires a highly precise frequency."
                },
                {
                    "name": "ShortTone",
                    "available": "All Microcontrollers",
                    "description": "ShortTone Frequency, Duration",
                    "funcdesc": "This command will produce the specified tone for the specified duration. Frequency is measured in units of 10 Hz, and Duration is in 1 ms units. Please note that this command may not produce the exact frequency specified. While it is accurate enough for error beeps and small pieces of monophonic music, it should not be used for anything that requires a highly precise frequency."
                },
                {
                    "name": "Play",
                    "available": "All Microcontrollers",
                    "description": "Play SoundPlayDataString",
                    "funcdesc": "This command will plays a QBASIC sequence of notes. The SoundPlayDataString is a string representing a musical note or notes to play where Notes are A to G."
                },
                {
                    "name": "PlayRTTTL",
                    "available": "All Microcontrollers",
                    "description": "PlayRTTTL SoundPlayRTTTLDataString",
                    "funcdesc": "This command will play a sequence of notes in the Nokia RTTTL string format.\n\nThe SoundPlayRTTTLDataString is a string representing a musical note or notes to play where Notes are A to G. This format and information below is credited to WikiPedia, see here. To be recognized by ringtone programs, an RTTTL/Nokring format ringtone must contain three specific elements: name, settings, and notes."
                },
                {
                    "name": "ClearTimer",
                    "available": "All Microcontrollers",
                    "description": "ClearTimer TimerNo",
                    "funcdesc": "ClearTimer is used to clear the specified timer to a value of 0.\n\nCleartimer can be used on-the-fly if desired, so there is no requirement to stop the timer first"
                },
                {
                    "name": "InitTimer0",
                    "available": "All Microcontrollers",
                    "description": "InitTimer0 source, prescaler",
                    "funcdesc": "InitTimer0 will set up timer 0.\n\nWhen the timer overflows from 255 to 0, a Timer0Overflow interrupt will be generated. This can be used in conjunction with On Interrupt to run a section of code when the overflow occurs."
                },
                {
                    "name": "InitTimer1",
                    "available": "All Microcontrollers",
                    "description": "InitTimer1 source, prescaler",
                    "funcdesc": "InitTimer1 will set up timer 1.\n\nWhen the timer overflows an interrupt event will be generated. This interrupt event can be used in conjunction with On Interrupt to run a section of code when the interrupt event occurs."
                },
                {
                    "name": "InitTimer2",
                    "available": "All Microcontrollers",
                    "description": "InitTimer2 prescaler",
                    "funcdesc": "This the most common method to initialise a Microchip microcontroller timer.  With this method the timer has only one possible clock source, this mandated by the microcontrollers architecture, and that clock source is the System Clock/4 also known as FOSC/4. \n\nThe second method is much more flexible in term of the clock source.  Microcontrollers that support this second method enable you to select different clock sources and to select more prescale values."
                },
                {
                    "name": "InitTimer3",
                    "available": "All Microcontrollers",
                    "description": "InitTimer3 source, prescaler",
                    "funcdesc": "InitTimer3 will set up timer 3\n\nWhen the timer overflows an interrupt event will be generated. This interrupt event can be used in conjunction with On Interrupt to run a section of code when the interrupt event occurs."
                },
                {
                    "name": "InitTimer4",
                    "available": "All Microcontrollers",
                    "description": "InitTimer4 prescaler, postscaler",
                    "funcdesc": "This the most common method to initialise a Microchip microcontroller timer.  With this method the timer has only one possible clock source, this mandated by the microcontrollers architecture, and that clock source is the System Clock/4 also known as FOSC/4. \n\nThe second method is much more flexible in term of the clock source.  Microcontrollers that support this second method enable you to select different clock sources and to select more prescale values."
                },
                {
                    "name": "InitTimer5",
                    "available": "All Microcontrollers",
                    "description": "InitTimer5 source, prescaler",
                    "funcdesc": "InitTimer5 will set up timer 5.\n\nWhen the timer overflows an interrupt event will be generated. This interrupt event can be used in conjunction with On Interrupt to run a section of code when the interrupt event occurs. "
                },
                {
                    "name": "InitTimer6",
                    "available": "All Microcontrollers",
                    "description": "InitTimer6 prescaler, postscaler",
                    "funcdesc": "This the most common method to initialise a Microchip microcontroller timer.  With this method the timer has only one possible clock source, this mandated by the microcontrollers architecture, and that clock source is the System Clock/4 also known as FOSC/4.\n\nThe second method is much more flexible in term of the clock source.  Microcontrollers that support this second method enable you to select different clock sources and to select more prescale values."
                },
                {
                    "name": "InitTimer7",
                    "available": "All Microcontrollers",
                    "description": "InitTimer7 source, prescaler",
                    "funcdesc": "InitTimer7 will set up timer 7.\n\nWhen the timer overflows an interrupt event will be generated. This interrupt event can be used in conjunction with On Interrupt to run a section of code when the interrupt event occurs. "
                },
                {
                    "name": "InitTimer8",
                    "available": "All Microcontrollers",
                    "description": "InitTimer8 prescaler, postscalere",
                    "funcdesc": "This the most common method to initialise a Microchip microcontroller timer.  With this method the timer has only one possible clock source, this mandated by the microcontrollers architecture, and that clock source is the System Clock/4 also known as FOSC/4.\n\nThe second method is much more flexible in term of the clock source.  Microcontrollers that support this second method enable you to select different clock sources and to select more prescale values."
                },
                {
                    "name": "InitTimer10",
                    "available": "All Microcontrollers",
                    "description": "InitTimer10 prescaler, postscaler",
                    "funcdesc": "Defines a Variable Type"
                },
                {
                    "name": "InitTimer12",
                    "available": "All Microcontrollers",
                    "description": "InitTimer12 prescaler, postscaler",
                    "funcdesc": "Defines a Variable Type"
                },
                {
                    "name": "Settimer",
                    "available": "All Microcontrollers",
                    "description": "Settimer timernumber, byte_value",
                    "funcdesc": "Settimer will set the value of the specified timer with either byte value or a word value. 8-bit timers use a byte value. 16-bit timers use a word value.\n\nSettimer can be used on-the-fly, so there is no requirement to stop the timer first.\n\nRefer to the datasheet for timer specific information."
                },
                {
                    "name": "StartTimer",
                    "available": "All Microcontrollers",
                    "description": "StartTimer TimerNo",
                    "funcdesc": "Please refer to the datasheet to determine if Timer 0 on specific Microchip PIC microcontroller can be started and stopped with starttimer and stoptimer. If the Microchip PIC microcontroller has a register named \"T0CON\" then it supports stoptimer and starttimer.\nOn Microchip PIC 18(L)Fxxx microcontrollers Timer 0 can be started with starttimer.\nOn Microchip PIC baseline and midrange microcontrollers starttimer (and stoptimer) has no effect upon Timer 0."
                },
                {
                    "name": "StopTimer",
                    "available": "All Microcontrollers",
                    "description": "StopTimer TimerNo",
                    "funcdesc": "Defines a Variable Type"
                },
                {
                    "name": "BcdToDec",
                    "available": "All Microcontrollers",
                    "description": "BcdToDec ( ByteVariable )",
                    "funcdesc": "Converts numbers from Binary Coded Decimal format to decimal.\n\nYou can add this function. Just add this to your Great Cow BASIC program and then call it when you need it."
                },
                {
                    "name": "DecToBcd",
                    "available": "All Microcontrollers",
                    "description": "DecToBcd( ByteVariable )",
                    "funcdesc": "Converts numbers from Decimal to Binary Coded Decimal format. Support Bytes only.\n\nYou can add this function. Just add this to your Great Cow BASIC program and then call it when you need it"
                },
                {
                    "name": "Rotate",
                    "available": "All Microcontrollers",
                    "description": "Rotate variable {Left | Right} [Simple]",
                    "funcdesc": "The Rotate command will rotate variable one bit in a specified direction. The bit shifted will be placed in the Carry bit of the Status register (STATUS.C). STATUS.C acts as a ninth bit of the variable that is being rotated.\n\nvariable supports Bytes, Word and Long variables.\n\nWhen a variable is rotated right, the bit in the STATUS.C location is placed into the MSB of the variable being rotated, and the LSB of the variable is placed into STATUS.C location.\n\nWhen rotated left the opposite occurs. The MSB of the variable is shifted to the STATUS.C bit and the LSB of the variable will contain what was previously in the STATUS.C bit location."
                },
                {
                    "name": "Set",
                    "available": "All Microcontrollers",
                    "description": "Set variable.bit {On | Off}",
                    "funcdesc": "The purpose of the Set command is to turn individuals bits on and off.\n\nThe Set command is most useful for controlling output ports, but can also be used to set variables.\n\nOften when controlling output ports, Set is used in conjunction with constants. This makes it easier to adapt the program for a new circuit later."
                },
                {
                    "name": "SWAP4",
                    "available": "All Microcontrollers",
                    "description": "SWAP4( VariableA)",
                    "funcdesc": "A function that swaps (or exchanges) nibbles (or the 8 bits of a byte in nibbles)."
                },
                {
                    "name": "SWAP",
                    "available": "All Microcontrollers",
                    "description": "SWAP( VariableA, VariableB)",
                    "funcdesc": "A function that swaps (or exchanges) one byte or word for another. SWAP support the use of byte and word variables."
                },
                {
                    "name": "ASC",
                    "available": "All Microcontrollers",
                    "description": "bytevar= ASC(string, [position] )",
                    "funcdesc": "ASC returns the character code of a particular character in the string. If the string is an ANSI string, the returned value will be in the range of 0 to 255. This function DOES NOT support UNICODE.\n\nThe optional position parameter determines which character is to be checked. The first character is one, the second two, etc. If the position parameter is missing, the first character is presumed.\n\nCHR is the natural complement of ASC. CHR produces a one-character string corresponding to its ASCII"
                },
                {
                    "name": "ByteToBin",
                    "available": "All Microcontrollers",
                    "description": "stringvar = ByteToBin(bytevar)",
                    "funcdesc": "The ByteToBin function creates a string of a ANSI (8-byte) characters. The function converts a number to a string consisting of ones and zeros that represents the binary value."
                },
                {
                    "name": "CHR",
                    "available": "All Microcontrollers",
                    "description": "stringvar = CHR(bytevar)",
                    "funcdesc": "DThe CHR function creates a string of a ANSI (1-byte) character.\n\nASC is the natural complement of CHR."
                },
                {
                    "name": "Fill",
                    "available": "All Microcontrollers",
                    "description": "stringvar =  Fill ( byte_value_of_the_new_length , pad_character )",
                    "funcdesc": "The Fill function is used to create string to a specific length that is of a specific character.\n\nThe length of the string is specified by the first parameter. The character used to pad the string is specified by the second parameter, this parameter is optional as the \" \"(space) character is assumed.\n\nA typical use is to fill a string to be displayed on an LCD or serial terminal"
                },
                {
                    "name": "Hex",
                    "available": "All Microcontrollers",
                    "description": "stringvar = Hex(number)",
                    "funcdesc": "The Hex function will convert a number into hexadecimal format. The input number should be a byte variable, or a fixed number between 0 and 255 inclusive. After running the function, the string variable stringvar will contain a 2 digit hexadecimal number."
                },
                {
                    "name": "Instr",
                    "available": "All Microcontrollers",
                    "description": "location = Instr(source, find)",
                    "funcdesc": "The Instr function will search one string to find the location of another string within it. source is the string to search inside, and find is the string to find. The function will return the location of find within source, or 0 if source does not contain find."
                },
                {
                    "name": "LCase",
                    "available": "All Microcontrollers",
                    "description": "output = LCase(source)",
                    "funcdesc": "The LCase function will convert all of the letters in the string source to lower case, and return the result."
                },
                {
                    "name": "Left",
                    "available": "All Microcontrollers",
                    "description": "output = Left(source, count)",
                    "funcdesc": "The Left function will extract the leftmost count characters from the input string source, and return them in a new string."
                },
                {
                    "name": "LeftPad",
                    "available": "All Microcontrollers",
                    "description": "LeftPad(string_variable,byte_value_of_the_new_length,pad_character)",
                    "funcdesc": "The LeftPad function is used to create string to a specific length that is extended with a specific character to the left hand side of the string.\n\nThe length of the string is specified by the second parameter.\n\nThe character used to pad the string is specified by the third parameter.\n\nA typical use is to pad a string to be displayed on a serial terminal or LCD."
                },
                {
                    "name": "Len",
                    "available": "All Microcontrollers",
                    "description": "output= Len( string )",
                    "funcdesc": "The Len function returns an byte value which is the length of a phrase or a sentence, including the empty spaces. The format is:\n\ntarget_byte_variable = Len(\"Phrase\")\n\nor another example. This code will loop through the for-next loop 12 times as determined by the length of the string:\n\ncreate a test string of 12 characters\ndim teststring as string * 12\n\nteststring = \"0123456789AB\"\nfor loopthrustring = 1 to len(teststring)\nhserprint mid(teststring, loopthrustring , 1)\nnext"
                },
                {
                    "name": "LTRIM",
                    "available": "All Microcontrollers",
                    "description": "stringvar = LTRIM(stringvar)",
                    "funcdesc": "The Ltrim function will trim the 7-bit ASCII space character (value 32) from the LEFT hand side of a string.\n\nUse Ltrim on text that you have received from another source that may have irregular spacing at the left hand end of the string."
                },
                {
                    "name": "Mid",
                    "available": "All Microcontrollers",
                    "description": "output = Mid(source, start[, count])",
                    "funcdesc": "The Mid function returns a string variable containing a specified number of characters from a source string.\n\nsource is the variable to extract from. If source is a zero length string - a zero length string is returned equating to \"\".\nstart is the position of the first character to extract. If start is greater than the number of characters in string, Mid returns a zero-length string equating to \"\".\ncount is the number of characters to extract. If count is not specified, all characters from start to the end of the source string will be returned."
                },
                {
                    "name": "Pad",
                    "available": "All Microcontrollers",
                    "description": "Dout_string = Pad",
                    "funcdesc": "The Pad function is used to create string to a specific length that is extended with a specific character.\n\nThe length of the string is specified by the second parameter. The character used to pad the string is specified by the third parameter.\n\nA typical use is to pad a string to be displayed on a LCD display."
                },
                {
                    "name": "Right",
                    "available": "All Microcontrollers",
                    "description": "output = Right(source, count)",
                    "funcdesc": "Defines a Variable Type"
                },
                {
                    "name": "Rtrim",
                    "available": "All Microcontrollers",
                    "description": "stringvar = Rtrim(stringvar)",
                    "funcdesc": "The Rtrim function will trim the 7-bit ASCII space character (value 32) from the RIGHT hand side of a string.\n\nUse Rtrim on text that you have received from another source that may have irregular spacing at the right hand end of the string."
                },
                {
                    "name": "Str",
                    "available": "All Microcontrollers",
                    "description": "stringvar = Str(number)",
                    "funcdesc": "The Str function will convert a number into a string. number can be any byte or word variable, or a fixed number between 0 and 65535 inclusive.  For Long numbers use Str32 and for Integer numbers use StrInteger.\n\nThe string variable stringvar will contain the same number, represented as a string.  The length of the string returned is 5, 10 or 6 characters for Byte & Word, Long and Integer respectively.\n\nThis function is especially useful if a number needs to added to the end of a string, or if a custom data sending routine has been created but only supports the output of string variables."
                },
                {
                    "name": "Trim",
                    "available": "All Microcontrollers",
                    "description": "stringvar = Trim(stringvar)",
                    "funcdesc": "The Trim function will trim the 7-bit ASCII space character (value 32) from text.\n\nTrim removes all spaces from text except for single spaces between words. Use Trim on text that you have received from another source that may have irregular spacing at the left or right hand ends of the string"
                },
                {
                    "name": "UCase",
                    "available": "All Microcontrollers",
                    "description": "output = UCase(source)",
                    "funcdesc": "The UCase function will convert all of the letters in the string source to upper case, and return the result."
                },
                {
                    "name": "Val",
                    "available": "All Microcontrollers",
                    "description": "var = Val(string)",
                    "funcdesc": "The Val function will extract a number from a string variable, and store it in a word variable. One potential use is reading numbers that are sent in ASCII format over a serial connection.\n\nThe Val32 function will extract a long number from a string variable, and store it in a long variable."
                },
                {
                    "name": "IntegerToBin",
                    "available": "All Microcontrollers",
                    "description": "stringvar = IntegerToBin(integervar)",
                    "funcdesc": "The IntegerToBin function creates a string of a ANSI (signed 15 digit string ) characters. The function converts a number to a string consisting of ones and zeros that represents the binary value."
                },
                {
                    "name": "LongToBin",
                    "available": "All Microcontrollers",
                    "description": "stringvar = LongToBin(longvar)",
                    "funcdesc": "The LongToBin function creates a string of a ANSI (32) characters. The function converts a number to a string consisting of ones and zeros that represents the binary value."
                },
                {
                    "name": "WordToBin",
                    "available": "All Microcontrollers",
                    "description": "stringvar = WordToBin(bytevar)",
                    "funcdesc": "The WordToBin function creates a string of a ANSI (8-byte) characters. The function converts a number to a string consisting of ones and zeros that represents the binary value."
                },
                {
                    "name": "Dir",
                    "available": "All Microcontrollers",
                    "description": "Dir port.bit {In | Out}",
                    "funcdesc": "The Dir command is used to set the direction of the ports of the microcontroller chip. The individual form sets the direction of one pin at a time, whereas the entire port form will set all bits in a port.\n\nIn the individual form, specify the port and bit (ie. PORTB.4), then the direction, which is either In or Out.\n\nThe entire port form is similiar to the TRIS instruction offered by some Microchip PIC microcontrollers. To use it, give the name of the port (i.e. PORTA), and then a byte is to be written into the TRIS variable. This form of the command is for those who are familiar with the Microchip PIC microcontrollers internal architecture.\n\nNote: Entire port form will work differently on Atmel AVR microcontrollers when a value other than IN or OUT is used. Atmel AVR microcontrollers use 0 to indicate in and 1 to indicate out, whereas Microchip PIC microcontrollers use 0 for out and 1 for in. When IN and OUT are used there are no compatibility issues."
                },
                {
                    "name": "GetUserID",
                    "available": "Microchip PIC",
                    "description": "UserIDRegister  = GetUserID(Index)",
                    "funcdesc": "Reads the memory location and returns the ID for a specific microcontroller.\n\nIf the microcontroller does not support GetUSerID then the following message will be issued during compilation Warning: GetUserID not supported by this microcontroller."
                },
                {
                    "name": "Pot",
                    "available": "All Microcontrollers",
                    "description": "Pot pin, output",
                    "funcdesc": "Pot makes it possible to measure an analog resistance with a digital port, with the addition of a small capacitor.\n\nThe command works by using the microcontroller pin to discharge the capacitor, then measuring the time taken for the capacitor to charge again through the resistor.\n\nThe value for the capacitor must be adjusted depending on the size of the variable resistor. The charging time needs to be approximately 2.5 ms when the resistor is at its maximum value. For a typical 50 k potentiometer or LDR, a 50 nf capacitor is required.\n\nThis command should be used carefully. Each time it is inserted, 20 words of program memory are used on the chip, which as a rough guide is more than 15 times the size of the Set command.\npin is the port connected to the circuit. The direction of the pin will be dealt with by the Pot command.\noutput is the name of the variable that will receive the value."
                },
                {
                    "name": "PulseOut",
                    "available": "All Microcontrollers",
                    "description": "PulseOut pin, time units",
                    "funcdesc": "The PulseOut command will set the specified pin high, wait for the specified amount of time, and then set the pin low again. The pin is specified in the same way as it is for the Set command, and the time is the same as for the Wait command."
                },
                {
                    "name": "PulseOutInv",
                    "available": "All Microcontrollers",
                    "description": "PulseOutInv pin, time units",
                    "funcdesc": "The PulseOutInv command will set the specified pin low, wait for the specified amount of time, and then set the pin high. The pin is specified in the same way as it is for the Set command, and the time is the same as for the Wait command."
                },
                {
                    "name": "PulseIn",
                    "available": "All Microcontrollers",
                    "description": "PulseIn pin, user_variable, time units",
                    "funcdesc": "The PulseIn command will monitor the specified pin when the pin is high, and then measure the high time. It will store the time in the user variable. The user variable must be a WORD if returned units are expected to be > 255 (Example: Pulse is 500 ms).\n\nPulseIn is not recommended for accurate measurement of microsecond pulses."
                },
                {
                    "name": "PulseInInv",
                    "available": "All Microcontrollers",
                    "description": "PulseInInv pin, user_variable, time units",
                    "funcdesc": "The PulseIn command will monitor the specified pin when the pin is high, and then measure the high time. It will store the time in the user variable. The user variable must be a WORD if returned units are expected to be > 255 (Example: Pulse is 500 ms).\n\nPulseIn is not recommended for accurate measurement of microsecond pulses."
                },
                {
                    "name": "Peek",
                    "available": "All Microcontrollers",
                    "description": "OutputVariable = Peek (location)",
                    "funcdesc": "The Peek function is used to read information from the on-chip RAM of the microcontroller.\n\nlocation is a word variable that gives the address to read. The exact range of valid values varies from chip to chip.\n\nThis command should not normally be used, as it will make the porting of code to another chip very difficult."
                },
                {
                    "name": "Poke",
                    "available": "All Microcontrollers",
                    "description": "Poke(location, value)",
                    "funcdesc": "The Poke command is used to write information to the on-chip RAM of the microcontroller.\n\nlocation is a word variable that gives the address to write. The exact range of valid values varies from chip to chip. value is the data to write to the location.\n\nThis command should not normally be used, as it will make the porting of code to another chip very difficult."
                },
                {
                    "name": "Abs",
                    "available": "All Microcontrollers",
                    "description": "integer_variable = Abs( integer_variable )",
                    "funcdesc": "The Abs function will compute the absolute value of a integer number therefore in the range of 32767 to +32767."
                },
                {
                    "name": "Average",
                    "available": "All Microcontrollers",
                    "description": "integer_variable = Average",
                    "funcdesc": "A function that returns the average of two numbers. This only supports byte variables.\n\nProvides a very fast way to calculate the average of two 8 bit numbers."
                },
                {
                    "name": "Difference",
                    "available": "All Microcontrollers",
                    "description": "Difference ( word_variable1 , word_variable2 )",
                    "funcdesc": "A function that returns the difference between of two numbers. This only supports byte or word variables."
                },
                {
                    "name": "Log2",
                    "available": "All Microcontrollers",
                    "description": "returned_word_variable = Log2 ( word_value )",
                    "funcdesc": "The Log2 command will return the base-2 logarithm, to 2 decimal places.\n\nThe values returned are fixed-point numbers, with two decimal places assumed on the right. or if you prefer, think of the values as being scaled up by 100."
                },
                {
                    "name": "Loge",
                    "available": "All Microcontrollers",
                    "description": "returned_word_variable = Loge ( word_value )",
                    "funcdesc": "The Loge command will return the base-e logarithm, to 2 decimal places.\n\nThe values returned are fixed-point numbers, with two decimal places assumed on the right. or if you prefer, think of the values as being scaled up by 100."
                },
                {
                    "name": "Log10",
                    "available": "All Microcontrollers",
                    "description": "returned_word_variable = Log10 (word_value)",
                    "funcdesc": "The Log10 command will return the base-10 logarithm, to 2 decimal places.\n\nThe values returned are fixed-point numbers, with two decimal places assumed on the right. or if you prefer, think of the values as being scaled up by 100."
                },
                {
                    "name": "Power",
                    "available": "All Microcontrollers",
                    "description": "power( base, exponent )",
                    "funcdesc": "This function raises a base to an exponent, i.e, power(base,exponent). Calculation powers will become large, in terms of long numbers, you must ensure the program manage numbers remain within range of the defined variables.\n\nThe base and exponent are Byte sized numbers in this method.\nThe returned result is a Long.\nNon-negative numbers are assumed throughout."
                },
                {
                    "name": "Scale",
                    "available": "All Microcontrollers",
                    "description": "integer_variable = Scale (value_word , fromLow_integer , fromHigh_integer , toLow_integer , toHigh_integer [, calibration_integer] )",
                    "funcdesc": "Scales, re-maps, a number from one range to another.   That is, a value of fromLow would gets scaled to toLow, a value of fromHigh to toHigh, values in-between to values in-between, etc.\n\nThe method does not constrain values to within the integer range returned, because out-of-range values are sometimes intended and useful.\n\nNote that the \"lower bounds\" of either range may be larger or smaller than the \"upper bounds\" so the scale() method may be used to reverse a range of numbers"
                },
                {
                    "name": "sqrt",
                    "available": "All Microcontrollers",
                    "description": "word_variable = sqrt ( word )",
                    "funcdesc": "A square root routine for Great Cow BASIC. The function only involves bit shifting, addition and subtraction, which makes it fast and efficient.\n\nThis method required a word variable as the input and a word variable as the output. The method will handle arguments of up to 4294."
                },
                {
                    "name": "sin",
                    "available": "All Microcontrollers",
                    "description": "byte_variable = sin( word_variable )",
                    "funcdesc": "Great Cow BASIC supports Three Primary Trigonometric Functions\n\nGreat Cow BASIC supports the following functions, sin(x), cos(x), tan(x), where x is a signed integer representing an angle measured in a whole number of degrees. The output values are also integers, represented as fixed point decimal fractions."
                },
                {
                    "name": "cos",
                    "available": "All Microcontrollers",
                    "description": "byte_variable = cos( word_variable )",
                    "funcdesc": "Great Cow BASIC supports Three Primary Trigonometric Functions\n\nGreat Cow BASIC supports the following functions, sin(x), cos(x), tan(x), where x is a signed integer representing an angle measured in a whole number of degrees. The output values are also integers, represented as fixed point decimal fractions."
                },
                {
                    "name": "tan",
                    "available": "All Microcontrollers",
                    "description": "byte_variable = tan( word_variable )",
                    "funcdesc": "Great Cow BASIC supports Three Primary Trigonometric Functions\n\nGreat Cow BASIC supports the following functions, sin(x), cos(x), tan(x), where x is a signed integer representing an angle measured in a whole number of degrees. The output values are also integers, represented as fixed point decimal fractions."
                },
                {
                    "name": "atan",
                    "available": "All Microcontrollers",
                    "description": "byte_variable = atan (x_vector,y_vector)",
                    "funcdesc": "Great Cow BASIC supports the following functions ATan( x, y) where x and y are the vectors. The function returns a word representing the angle measured in a whole number of degrees.\n\nThe function also returns a global variable NegFlag with returns the quadrant of the angle."
                },
                {
                    "name": "UNLOCKPPS",
                    "available": "All Microcontrollers",
                    "description": "UNLOCKPPS",
                    "funcdesc": "Peripheral Pin Select (PPS) has an operation mode in which all input and output selections can be prevented to stop inadvertent changes.\n\nPPS selections are unlocked by setting by the use of the UnLockPPS command.\n\nUsing this command will ensure the special sequence of Microchip assembler is handled correctly."
                },
                {
                    "name": "LOCKPSS",
                    "available": "All Microcontrollers",
                    "description": "LOCKPSS",
                    "funcdesc": "Peripheral Pin Select (PPS) has an operation mode in which all input and output selections can be prevented to stop inadvertent changes.\n\nPPS selections are locked by setting by the use of the LockPPS command.\n\nUsing this command will ensure the special sequence of Microchip assembler is handled correctly."
                },
                {
                    "name": "Macro",
                    "available": "All Microcontrollers",
                    "description": "Macro MacroName (var1, var2, varN)",
                    "funcdesc": "Macros are similar to subroutines. But during compilation, everything is inserted inline. This may increase the code size slightly, but it also reduces stack usage.\n\nParameters are handled in a similar way to how constants are handled, so there is a lot more freedom when passing things in to a macro. (Unlike subs or functions, where everything must be stored in a variable.)"
                },
                {
                    "name": "RaiseCompilerError",
                    "available": "All Microcontrollers",
                    "description": "RaiseCompilerError \"string message\"",
                    "funcdesc": "From build 1131 the compiler now supports raising a compiler error message.\n\nThe method uses the RaiseCompilerError method to pass an error message to the assembler process (not the compilation process - the user will not know this).\n\nAn example from USART.H/INITUSART subroutine is shown below.  This example tests for the existence of one of the three supported baud rate constants.  If none of the constants exist and the constant (in this example) STOPCOMPILERERRORHANDLER does not exist the RaiseCompilerError with the string will be passed to the assembler for error processing.   This permits the inspect of the user program with appropriate messages to inform the user.\n\n....\n#IFNDEF ONEOF(USART_BAUD_RATE,USART1_BAUD_RATE,USART2_BAUD_RATE) THEN\n'Look for one of the baud rates CONSTANTS\n#IFNDEF STOPCOMPILERERRORHANDLER\nRaiseCompilerError \"USART not setup correctly. No baud rate specified - please correct USART setup\"\n#ENDIF\n#ENDIF\n....\n\n\n The RaiseCompilerError handler can be stopped using the constant STOPCOMPILERERRORHANDLER as shown above."
                },
                {
                    "name": "tmSndDec",
                    "available": "All Microcontrollers",
                    "description": "tmSndDec Value, [Optional position{Disp_Len}], [Optional number of digits{Disp_Len}]",
                    "funcdesc": "- TM1637/1638 OEM Lib:  Disp. value as decimal (Max. value 999999)"
                },
                {
                    "name": "tmSndHex",
                    "available": "All Microcontrollers",
                    "description": "tmSndHex Value, [Optional position{Disp_Len}], [Optional number of digits{Disp_Len}]",
                    "funcdesc": "- STM1637/1638 OEM Lib:  Disp. value as Hex (Max. value 16777215)"
                },
                {
                    "name": "tmSndDig",
                    "available": "All Microcontrollers",
                    "description": "tmSndDig byte value, position",
                    "funcdesc": "- Send 1 raw byte to TM1637"
                },
                {
                    "name": "tmSndStr",
                    "available": "All Microcontrollers",
                    "description": "tmSndStr \"Text\", [Optional buffer name{DispBuf}], [Optional send buffer On/Off {On}]",
                    "funcdesc": "- Send String to TM1637 (Set Var 'TMscroll = On' for long strings)"
                },
                {
                    "name": "tmSndChr",
                    "available": "All Microcontrollers",
                    "description": "tmSndChr \"chr\", position",
                    "funcdesc": "- Send 1 alphanumeric character to TM1637/1638"
                },
                {
                    "name": "tmChrBuf",
                    "available": "All Microcontrollers",
                    "description": "tmChrBuf \"chr\", position, [Optional buffer name{DispBuf}]",
                    "funcdesc": "- Load display buffer with 1 ASCII character"
                },
                {
                    "name": "tmDecBuf",
                    "available": "All Microcontrollers",
                    "description": "tmDecBuf Value, [Optional position{Disp_Len}], [Optional number of digits{Disp_Len}], [Optional buffer name{DispBuf}]",
                    "funcdesc": "TM1637/1638 OEM Lib: - Load display buffer with Decimal digits"
                },
                {
                    "name": "tmHexBuf",
                    "available": "All Microcontrollers",
                    "description": "tmHexBuf Value, [Optional position{Disp_Len}], [Optional number of digits{Disp_Len}], [Optional buffer name{DispBuf}]",
                    "funcdesc": "TM1637/1638 OEM Lib: - Load display buffer with Hex digits"
                },
                {
                    "name": "tmSegBuf",
                    "available": "All Microcontrollers",
                    "description": "tmSegBuf digit number, segment number, On/Off, [Optional buffer name{DispBuf}], [Optional send digit {Off}]",
                    "funcdesc": "TM1637/1638 OEM Lib: - Set segment in display buffer [send option{Off}]"
                },
                {
                    "name": "tmSndBuf",
                    "available": "All Microcontrollers",
                    "description": "tmSndBuf [Optional position{Disp_Len}], [Optional number of digits{Disp_Len}], [Optional buffer name{DispBuf}]",
                    "funcdesc": "TM1637/1638 OEM Lib: - Send display buffer to TM1637"
                },
                {
                    "name": "tmFlashDsp",
                    "available": "All Microcontrollers",
                    "description": "tmFlashDsp",
                    "funcdesc": "TM1637/1638 OEM Lib: - Flash whole display"
                },
                {
                    "name": "tmFlashDig",
                    "available": "All Microcontrollers",
                    "description": "tmFlashDig Digit number, [Optional number of digits{1}], [Optional Buffer name{DispBuf}]",
                    "funcdesc": "TM1637/1638 OEM Lib: - Flash digit(s) Buffer must be current"
                },
                {
                    "name": "tmFlashSeg",
                    "available": "All Microcontrollers",
                    "description": "tmFlashSeg Digit number, Segment number, [Optional Buffer name{DispBuf}]",
                    "funcdesc": "TM1637/1638 OEM Lib: - Flash segment Buffer must be current"
                },
                {
                    "name": "tmCLRbuf",
                    "available": "All Microcontrollers",
                    "description": "tmCLRbuf [Optional position{Disp_Len}], [Optional number of digits{Disp_Len}], [Optional buffer name{DispBuf}]",
                    "funcdesc": "TM1637/1638 OEM Lib: - Clear display buffer"
                },
                {
                    "name": "tmCLRdisp",
                    "available": "All Microcontrollers",
                    "description": "tmCLRdisp",
                    "funcdesc": "TM1637/1638 OEM Lib: - Clear all display digits"
                },
                {
                    "name": "tmCtrlSnd",
                    "available": "All Microcontrollers",
                    "description": "tmCtrlSnd",
                    "funcdesc": "TM1637/1638 OEM Lib: - Send TM1637 Control Byte"
                },
                {
                    "name": "tmGetKey",
                    "available": "All Microcontrollers",
                    "description": "tmGetKey",
                    "funcdesc": "TM1637/1638 OEM Lib: - Get Keypressed, Button Number set in 'BtnVal' Var"
                },
                {
                    "name": "tmScrlBuf",
                    "available": "All Microcontrollers",
                    "description": "tmScrlBuf Array name, [Optional Buffer name{DispBuf}]",
                    "funcdesc": "TM1637/1638 OEM Lib: - Scroll Buffer"
                },
                {
                    "name": "TM_1637_OEM_Lib-Variables",
                    "available": "All Microcontrollers",
                    "description": "TM_1637_OEM_Lib-Variables Settings/Options list...",
                    "funcdesc": "Following is a list of Variables to set for TM1637_OEM_Cmd_Lib.h"
                },
                {
                    "name": "TM_DispLen",
                    "available": "All Microcontrollers",
                    "description": "TM_DispLen (byte constant) TM1637/1638 Digit Length of 7seg display",
                    "funcdesc": "use as reference to right digit"
                },
                {
                    "name": "TM_6dReMap",
                    "available": "All Microcontrollers",
                    "description": "TM_6dReMap (bit var) TM1637/1638 Remap for 6d module (with swapped pins)",
                    "funcdesc": "TM_6dReMap = On/Off {default = Off}"
                },
                {
                    "name": "TM_Blank0",
                    "available": "All Microcontrollers",
                    "description": "TM_Blank0 (bit var) TM1637/1638 Enable zero Blanking",
                    "funcdesc": "TM_blank0 = On/Off {default = ON}"
                },
                {
                    "name": "TM_Bright",
                    "available": "All Microcontrollers",
                    "description": "TM_Bright (byte var) TM1637/1638 Set LED brightness",
                    "funcdesc": "TM_bright = Value (0 - 7) {default = 0}"
                },
                {
                    "name": "TM_Disp",
                    "available": "All Microcontrollers",
                    "description": "TM_Disp (bit var) Set TM1637/1638 display On or Off",
                    "funcdesc": "TM_disp = On/Off {default = ON}"
                },
                {
                    "name": "TM_dpPos",
                    "available": "All Microcontrollers",
                    "description": "TM_dpPos (byte var) TM1637/1638 Position of DecimalPoint",
                    "funcdesc": "TMdpPos = Value (1 - 6){default = 0} 0 = off"
                },
                {
                    "name": "TM_FlashRate",
                    "available": "All Microcontrollers",
                    "description": "TM_FlashRate (bit var) TM1637/1638 Set Flash Rate",
                    "funcdesc": "TM_FlashRate = Value (1 - 255) {default = 100} val"
                },
                {
                    "name": "TM_scroll",
                    "available": "All Microcontrollers",
                    "description": "TM_scroll (byte var) TM1637/1638 Scroll long strings",
                    "funcdesc": "TM_scroll = On/Off {default = Off}"
                },
                {
                    "name": "TM_ScrollRate",
                    "available": "All Microcontrollers",
                    "description": "TM_ScrollRate (byte var) TM1637/1638 Set scroll speed",
                    "funcdesc": "ScrollSpd = Value (1 - 255){default = 75} val"
                },
                {
                    "name": "TM_ButnVal",
                    "available": "All Microcontrollers",
                    "description": "TM_ButnVal (byte var) TM1637/1638 Button pressed value",
                    "funcdesc": "Set by tmGetKey (1 - 16)"
                },
                {
                    "name": "TM_KeyChk",
                    "available": "All Microcontrollers",
                    "description": "TM_KeyChk (bit var) TM1637/1638 Enable check keypress in TM_FlashRate",
                    "funcdesc": "TM_KeyChk = On/Off {default = Off}"
                },
                {
                    "name": "TM_LEDs",
                    "available": "All Microcontrollers",
                    "description": "TM_LEDs (byte constant)",
                    "funcdesc": "TM1637/1638 buffer use for discrete LED's"
                },
                {
                    "name": "TM_DispBuf",
                    "available": "All Microcontrollers",
                    "description": "TM_DispBuf (byte array)",
                    "funcdesc": " TM1637/1638 Display Buffer 7seg digit values (0 - 255)"
                },
                {
                    "name": "HSerSpace",
                    "available": "All Microcontrollers",
                    "description": "HSerSpace NumberOfSpaces, Comport1to5",
                    "funcdesc": "Use as reference to right digit"
                },
                                {
                    "name": "EEPROM",
                    "available": "All Microcontrollers with EEPROM memory",
                    "description": "EEPROM DataSetName [[,address]]",
                    "funcdesc": "The EEPROM construct creates an EEPROM dataset for use with the specific microcontroller. An EEPROM dataset is a list of values that are stored in the EEPROM memory of the microcontroller, which then can be accessed using the EPREAD() command or other EEPROM read operations."
                },
                {
                    "name": "Int",
                    "available": "All Microcontrollers",
                    "description": "Int( Single_Variable | Single_Constant )",
                    "funcdesc": "The `Int` function will compute the integer value of an integer number therefore will return the range of single variable."

                },
                {
                    "name": "RoundSingle",
                    "available": "All Microcontrollers",
                    "description": "RoundSingle( Single_Variable | Single_Constant )",
                    "funcdesc": "The `RoundSingle` function will return a floating point number that is a rounded version of the specified number."
                },
                {
                    "name": "ByteToString",
                    "available": "All Microcontrollers",
                    "description": "string_variable = ByteToString( Byte_Variable )",
                    "funcdesc": "The `ByteToString` function will convert a number into a string. `Byte_Variable` can be any byte variable, or a fixed number constant between 0 and 255 inclusive"

                },
                {
                    "name": "WordToString",
                    "available": "All Microcontrollers",
                    "description": "string_variable = WordToString( Word_Variable )",
                    "funcdesc" : "The `WordToString()` function will convert a number into a string. `Word_Variable` can be any word variable, or a fixed number constant"
                },
                {
                    "name": "IntegerToString",
                    "available": "All Microcontrollers",
                    "description": "string_variable = IntegerToString( Integer_Variable )",
                    "funcdesc" : "The `IntegerToString()` function will convert a number into a string. `Integer_Variable` can be any integer variable, or a fixed number constant"
                },
                {
                    "name": "LongToString",
                    "available": "All Microcontrollers",
                    "description": "string_variable = LongToString( Long_Variable )",
                    "funcdesc" : "The `LongToString()` function will convert a number into a string. `Long_Variable` can be any long variable, or a fixed number constant"
                },
                {
                    "name": "SingleToString",
                    "available": "All Microcontrollers",
                    "description": "string_variable = SingleToString( Single_Variable )",
                    "funcdesc" : "The `SingleToString()` function will convert a number into a string. `Single_Variable` can be any single variable, or a fixed number constant"
                },
                {
                    "name": "ByteToHex",
                    "available": "All Microcontrollers",
                    "description": "string_variable = ByteToHex( Byte_Variable )",
                    "funcdesc" : "The `ByteToHex()` function will convert a number into a hex string. `Byte_Variable` can be any byte variable, or a fixed number constant"
                },
                {
                    "name": "WordToHex",
                    "available": "All Microcontrollers",
                    "description": "string_variable = WordToHex( Word_Variable )",
                    "funcdesc" : "The `WordToHex()` function will convert a number into a hex string. `Word_Variable` can be any word variable, or a fixed number constant"
                },
                {
                    "name": "IntegerToHex",
                    "available": "All Microcontrollers",
                    "description": "string_variable = IntegerToHex( Integer_Variable )",
                    "funcdesc" : "The `IntegerToHex()` function will convert a number into a hex string. `Integer_Variable` can be any integer variable, or a fixed number constant"
                },
                {
                    "name": "LongToHex",
                    "available": "All Microcontrollers",
                    "description": "string_variable = LongToHex( Long_Variable )",
                    "funcdesc" : "The `LongToHex()` function will convert a number into a hex string. `Long_Variable` can be any long variable, or a fixed number constant"
                },
                {
                    "name": "SingleToHex",
                    "available": "All Microcontrollers",
                    "description": "string_variable = SingleToHex( Single_Variable )",
                    "funcdesc" : "The `SingleToHex()` function will convert a number into a hex string. `Single_Variable` can be any single variable, or a fixed number constant"
                },
                {
                    "name": "TM_dpPos",
                    "available": "All Microcontrollers",
                    "description": "TM_dpPos (byte var) TM1637/1638 Position of DecimalPoint",
                    "funcdesc": "TMdpPos = Value (1 - 6){default = 0} 0 = off"
                },
                {
                    "name": "ByteToBin",
                    "available": "All Microcontrollers",
                    "description": "string_variable = ByteToBin( Byte_Variable )",
                    "funcdesc" : "The `ByteToBin()` function will convert a number into a binary string. `Byte_Variable` can be any byte variable, or a fixed number constant"
                },
                {
                    "name": "WordToBin",
                    "available": "All Microcontrollers",
                    "description": "string_variable = WordToBin( Word_Variable )",
                    "funcdesc" : "The `WordToBin()` function will convert a number into a binary string. `Word_Variable` can be any word variable, or a fixed number constant"                    
                },
                {
                    "name": "IntegerToBin",
                    "available": "All Microcontrollers",
                    "description": "string_variable = IntegerToBin( Integer_Variable )",
                    "funcdesc" : "The `IntegerToBin()` function will convert a number into a binary string. `Integer_Variable` can be any integer variable, or a fixed number constant"                    
                },
                {
                    "name": "LongToBin",
                    "available": "All Microcontrollers",
                    "description": "string_variable = LongToBin( Long_Variable )",
                    "funcdesc" : "The `LongToBin()` function will convert a number into a binary string. `Long_Variable` can be any long variable, or a fixed number constant"                    
                },
                {
                    "name": "SingleToBin",
                    "available": "All Microcontrollers",
                    "description": "string_variable = SingleToBin( Single_Variable )",
                    "funcdesc" : "The `SingleToBin()` function will convert a number into a binary string. `Single_Variable` can be any single variable, or a fixed number constant"                    
                },
                {
                    "name": "StringToByte",
                    "available": "All Microcontrollers",
                    "description": "byte_variable = StringToByte( String_Variable )",
                    "funcdesc" : "The `StringToByte()` function will convert a string into a byte numeric value."                    
                },
                {
                    "name": "StringToWord",
                    "available": "All Microcontrollers",
                    "description": "word_variable = StringToWord( String_Variable )",
                    "funcdesc" : "The `StringToWord()` function will convert a string into a word numeric value."                    
                },
                {
                    "name": "StringToInteger",
                    "available": "All Microcontrollers",
                    "description": "integer_variable = StringToInteger( String_Variable )",
                    "funcdesc" : "The `StringToInteger()` function will convert a string into a integer numeric value."                    
                },
                {
                    "name": "StringToLong",
                    "available": "All Microcontrollers",
                    "description": "long_variable = StringToLong( String_Variable )",
                    "funcdesc" : "The `StringToLong()` function will convert a string into a long numeric value."                    
                },
                {
                    "name": "StringToSingle",
                    "available": "All Microcontrollers",
                    "description": "single_variable = StringToSingle( String_Variable )",
                    "funcdesc" : "The `StringToSingle()` function will convert a string into a single numeric value."                    
                },
                {
                    "name": "ULongIntToBin",
                    "available": "All Microcontrollers",
                    "description": "string_variable = ULongIntToBin( ULongInt_Variable )",
                    "funcdesc" : "The `ULongIntToBin()` function will convert a number into a binary string. `ULongInt_Variable` can be any ULonginteger variable, or a fixed number constant"                    
                },
                {
                    "name": "DATA",
                    "available": "All Microcontrollers",
                    "description": "DATA BlockName1 as Type",
                    "funcdesc" : "The `DATA` function will add data blocks to your program memory, should be terminated with `END DATA`"                    
                }
            ]
        }
    ]
}
